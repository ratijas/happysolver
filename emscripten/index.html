<!doctype html>
<html><head>
<meta charset="UTF-8">
<title>Happy Cube Solver Online</title>
<script>
 /* (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2231125-5', 'auto');
  ga('send', 'pageview');*/
</script>

<link rel="icon" href="favicon.ico" type="image/x-icon"/>
<!--<script id="stdpcs" src="stdpcs.js"></script>  -->
<script id="stdpcs" src="stdpcs_uni.js"></script>  
<script id="unimesh2" src="unified_mesh.js"></script>  
<!--<script id="one_cube" src="one_piece_cube.js"></script>     -->
<!--<script id="one_cube" src="one_marble_cube.js"></script>    -->

<script type="text/javascript" src="colorPick/color.all.min.js"></script> <!-- https://github.com/PitPik/colorPicker  -->
<script type="text/javascript" src="colorPick/jsColor.js"></script>
<script type="text/javascript" src="sha1.js"></script>

<script type="text/javascript">
"use strict"

// unified_mesh.js
// j_unified_meshes_all.txt
    
var gl = null
var prog = null
var model = { vtxBuf: null }

var resizeGl, mouseUp, mouseDown, mouseMove, mouseDblClick, mouseWheel, cpp_draw, cpp_slvrun, getTms
var setGrpCount, setEditAction, runningRestart, serializeCurrent, deserializeAndLoad, readCubeFromEditor, newRestart, conf
var stackState, textureParamCube, getCubeTextureHandle, readCubeTexCoord, loadSlvSimple, freeMeshAllocator
var readCubeToEditor, textureParamToEditor, getToothPossibilities, solveGo, readCubeFromSig, bucketAddFam, setPicCount
var postReadAllPics, goToSlv, stopSlvRun, aboutClick, exportModel

var ctrlPressed = false
var editCtx = null
var unimesh_keys = Object.keys(unimesh) // unimesh included above
var readFrameBuf = null, readFrameView = null // buffer for selection readPixels. don't want it managed by emscripten

var ACT_NONE = 0, ACT_ADD = 1, ACT_REMOVE = 2
var NR_KEEP_PREV = 1 // for newRestart

var colorPickCfg = null 
    
function start() 
{
    colorPickCfg = {
        customBG: '#222',
        readOnly: false,
        // patch: false,
        init: function(elm, colors) { // colors is a different instance (not connected to colorPicker)
          elm.style.backgroundColor = elm.value;
          // used to be rgbaMixCustom the color mixed with the customBG color (not relevant for me since alpha is 1.0 always)
          // if it is NaN, the check is false and the default is the 
          elm.style.color = colors.rgbaMixWhite.luminance <= 0.22 ? '#ddd' : '#222';
        },
        initStyle: 'display: hidden',
        mode: 'hsv-h',
        noAlpha: true,
        size: 1,
        appendTo: editBack,
        displayCallback:changeColor,
        multipleInstances:true
    }
    jsColorPicker('input.color', colorPickCfg);
    editBackColor.addEventListener("focus", function() { changedColFocus(editBackColor, true, 0) })
    editFrontColor.addEventListener("focus", function() { changedColFocus(editFrontColor, true, 1) })
    editBackColor.addEventListener("blur", function() { changedColFocus(editBackColor, false, 0) })
    editFrontColor.addEventListener("blur", function() { changedColFocus(editFrontColor, false, 1) })
    
  /*  picsAddFamily("Happy Cube", "hc")
    picsAddCube("Blue", "hc_blue")
    picsAddCube("Red", "hc_red")
    picsAddCube("Purple", "hc_purple")
    picsAddFamily("Profi Cube", "pc")
    picsAddCube("AAAA", "pc_aaa")
    picsAddCube("BBBB", "pc_bbbb")
    //return
*/

    resizeGl = Module.cwrap('resizeGl', null, ['number', 'number'])
    mouseDown = Module.cwrap('mouseDown', null, ['number', 'number', 'number'])
    mouseUp = Module.cwrap('mouseUp', null, ['number'])
    mouseMove = Module.cwrap('mouseMove', null, ['number', 'number', 'number', 'number'])
    mouseDblClick = Module.cwrap('mouseDblClick', null, ['number', 'number', 'number'])
    mouseWheel = Module.cwrap('mouseWheel', null, ['number'])
    cpp_draw = Module.cwrap('cpp_draw', 'boolean', ['number'])
    cpp_slvrun = Module.cwrap('cpp_slvrun', 'boolean', [])
    getTms = Module.cwrap('getTms', 'number', [])
    solveGo = Module.cwrap('solveGo', null, [])
    setGrpCount = Module.cwrap('setGrpCount', null, ['number', 'number'])
    setEditAction = Module.cwrap('setEditAction', null, ['number'])
    runningRestart  = Module.cwrap('runningRestart', null, [])
    serializeCurrent  = Module.cwrap('serializeCurrent', 'number', [])
    deserializeAndLoad = Module.cwrap('deserializeAndLoad', null, ['number'])
    readCubeFromEditor = Module.cwrap('readCubeFromEditor', null, ['number'])
    newRestart  = Module.cwrap('newRestart', null, ['number'])
    conf = Module.cwrap('conf', null, ['number'])
    stackState = Module.cwrap('stackState', null, ['number'])
    textureParamCube = Module.cwrap('textureParamCube', null, ['number','number','number','number','number','number','number','number','number',
                                                                // grpi,drawtype,r,g,b,r,g,b,isBlack
                                                               'string', 'string', 'string', 'number', 'string']) 
                                                               // back-hex, front-hex, black-selector, rot-angle, url
    getCubeTextureHandle = Module.cwrap('getCubeTextureHandle', 'number', ['number', 'number', 'number'])
    readCubeTexCoord = Module.cwrap('readCubeTexCoord', null, ['number','number','number','number','number','number','number'])
    loadSlvSimple = Module.cwrap('loadSlvSimple', null, ['string'])
    freeMeshAllocator = Module.cwrap('freeMeshAllocator', null, [])
    readCubeToEditor = Module.cwrap('readCubeToEditor', null, ['number', 'string'])
    textureParamToEditor = Module.cwrap('textureParamToEditor', null, ['number'])
    getToothPossibilities = Module.cwrap('getToothPossibilities', null, ['number', 'number'])
    readCubeFromSig = Module.cwrap('readCubeFromSig', 'number', ['number', 'string', 'string'])
    bucketAddFam = Module.cwrap('bucketAddFam', null, ['string', 'number', 'number', 'number'])
    setPicCount = Module.cwrap('setPicCount', null, ['number', 'number', 'number'])
    postReadAllPics = Module.cwrap('postReadAllPics', null, [])
    goToSlv = Module.cwrap('goToSlv', null, ['number'])
    stopSlvRun = Module.cwrap('stopSlvRun', null)
    aboutClick = Module.cwrap('aboutClick', null, ['number', 'number'])
    exportModel = Module.cwrap('exportModel', 'number', [])
   
    var pcsNum = countAllDefs(uni_pcs)     
    Module.ccall('cpp_start', null, ['number'], [(pcsNum + 12)*6]); // add 12 for possible additions using editor
    conf(true)
    
    loadStdPieces(uni_pcs)
    
    Module.ccall('initCubeEngine', 'boolean', ['string', 'number'], ["", 0])
    
    if (window.location.search.length > 0) {
        loadUrl(window.location.toString())
    }
    else { // load single cube of 1 happy cube piece on each face
        loadUrl("AQYAAAAAQAAQCARAAQAAAIAiNwjGLBIwCAA=")
    }


    doResize();

    mycanvas.onmousedown = handleMouseDown
    document.onmouseup = handleMouseUp
    document.onmousemove = handleMouseMove
    mycanvas.ondblclick = handleMouseDblClick
    mycanvas.onwheel = mycanvas.onmousewheel = handleMouseWheel // second one is for internet explorer
    editCanvas.onclick = handleEditCanvasClick
    //editCanvas.onmousemove = handleEditCanvasMove
    editCanvas.onmousedown = handleEditCanvasDown
    
    document.onkeydown = handleKeyDown
    document.onkeyup = handleKey  
    
    editBackColor.onkeydown = function(ev) { colKey(ev, 0) }
    editFrontColor.onkeydown = function(ev) { colKey(ev, 1) }
    aboutBack.onclick = function(ev) { triggerAbout(false, ev) }

    editFileInput.value = "" // firefox retains the value from last session
    editFileName.value = ""
   
    // start drawing
    requestAnimationFrame(animProgress)
    setInterval(sampleTms, 1000)
    
    addingCubeCheck.checked = true

    removingCubeCheck.checked = false

    setEditAction(ACT_ADD) 
    
    // editor init
    editCtx = editCanvas.getContext("2d")
    blank_tex.loadedOk = true

    ipicCanvas.height = 11*IPIC_TSZ + 2*EDIT_MARGIN
    ipicCanvas.width = 15*IPIC_TSZ + 2*EDIT_MARGIN

 //   var fid = picsAddFamily("Test Fam", "Test Fam", true)
 //   picsAddCube("Test Cube", "Test Cube", -1, true, fid)
    
}

function countAllDefs(pcs)
{
    var c = 0;
    for(var fami in pcs) {
        c += pcs[fami].p.length
    }
    return c;   
}

function loadStdPieces(pcs)
{
    var drawTypeFromStr = function(s) {
        switch(s) {
        case "color": return DRAW_COLOR
        case "mix": return DRAW_PROFI
        case "marble": return DRAW_MARBLE
        case "tex": return DRAW_TEX
        default: throw "Unknown drawType " + s
        }
    }
    
    var objGet = function(o, key, defVal, makeVal) {
        if (typeof(o[key]) !== 'undefined') {
            if (makeVal)
                return makeVal(o[key])
            else
                return o[key]
        }
        return defVal
    }

    var defBack = (new Colors({color:COLOR_BACK_DEFAULT})).colors
    var defFront = (new Colors({color:COLOR_FRONT_DEFAULT})).colors
    
    for(var fami in pcs) 
    {
        var fam = pcs[fami]
        var famDrawType = drawTypeFromStr(fam.drawType)
        var onResetSel = objGet(fam, 'onResetSel', 0)
        var first = true
        for(var pi in fam.p) 
        {
            var p = fam.p[pi]
            var grpi = readCubeFromSig(-1, p.sig, p.name) 
            if (first) {
                bucketAddFam(fam.famName, grpi, fam.p.length, onResetSel)
                first = false
            }
            
            p.drawType = objGet(p, 'drawType', famDrawType, drawTypeFromStr)
            p.cb = objGet(p, 'cb', defBack, function(s) { return (new Colors({color:s})).colors })
            p.cf = objGet(p, 'cf', defFront, function(s) { return (new Colors({color:s})).colors })
            p.lines = objGet(p, 'lines', 'auto')
            p.rotate = objGet(p, 'rotate', 0)
            p.img = objGet(p, 'img', "")
            
            textureParamCube(grpi, p.drawType, 
                     p.cb.rgb.r, p.cb.rgb.g, p.cb.rgb.b, 
                     p.cf.rgb.r, p.cf.rgb.g, p.cf.rgb.b, 
                     isColorsBlack(p.lines, p.cb, p.cf, p.drawType), 
                     p.cb.HEX, p.cb.HEX, p.lines, p.rotate, p.img) 

        }
        
    }
    
    postReadAllPics();
}


var pressedInCanvas = false
function handleMouseDown(event) {
    pressedInCanvas = true
    mouseDown( (event.button == 2)?1:0, event.clientX, event.clientY)
    //return false
}
function handleMouseUp(event) {
    pressedInCanvas = false
    mouseUp( (event.button == 2)?1:0)
    // returning false here breaks the spinbox
    //return false
}
var lastX = null, lastY = null
function handleMouseMove(event) {
    if (lastEditDrag)
        return handleEditCanvasMove(event)
    if (!pressedInCanvas)
        return true// avoid reacting to move outside the canvas (editor, input number breaks in chrome)
    if (event.clientX == lastX && event.clientY == lastY)
        return false; // for some reason this event arrives in clicks as well
    lastX = event.clientX
    lastY = event.clientY
    var but = event.buttons
    if (but === undefined)
        but = event.which // for safari

        
    mouseMove(but, ctrlPressed?1:0, event.clientX, event.clientY)
    return false
}
function handleMouseDblClick(event) {
    mouseDblClick(ctrlPressed?1:0, event.clientX, event.clientY);
    return false
}
function handleMouseWheel(event) {
    var d = event.wheelDelta
    mouseWheel( (d > 0) ? 16 : -16)
    return false
}

function handleKeyDown(event) {
    if (event.keyCode == '65' && event.ctrlKey) { //ctrl+A
        var s = window.prompt("slv data")
        if (s != "") {
            loadSlvSimple(s)
            return
        }
    }
    handleKey(event)
}

function handleKey(event) {
    if (event.ctrlKey == ctrlPressed)
        return;
    ctrlPressed = event.ctrlKey;
    mouseMove(0, ctrlPressed?1:0, lastX, lastY)
    return false
}

var lastFamAdded = ''
var pics_families = {} // make family id to { cubes: list of { cid: cube-id, grpi: group-index } }
var pics_cubes = {} // make cube id to { famid, picSel: array of 6 booleans for each piece (count is same as grp) }
var max_grpi = 0; // the largest cube number we've seen. used for adding more cubes in the ui
var currentOpenGrpPics = null; // the {id:str in html,index:int grpi} of the grp of the currently open individual pics selection or null if it's not open
var piece_sel_count = 0, pieces_needed = 0;

function addTextChild(elem, txt) {
    var dummy = document.createElement("DIV")
    dummy.innerHTML = txt
    elem.appendChild(dummy.firstChild)
}

function picsAddFamily(famName, id, editable) {
    
    id = id.replace(/[-\. ]/g, '_')
    var editTag = ''
    if (editable) {
        editTag = '<label class="addCubeBtn sc-btn" title="Add Cube" onclick="triggerAddCube(\'ID\')"/><span class="addCubeBtnIn"></span></label>'
    }
    var picsCtrl = '<div id="ID_frame" class="toppic"><div class="famtitle">\
    <input class="fam_check_box hidden mycheck" id="ID_fcheck" type="checkbox" onchange="on_fam_check(\'ID\', ID_fcheck.checked, true);" />\
    <label class="fam_check mycheck_label" id="ID_fcheck_label" for="ID_fcheck" ></label>ADDEDIT\
    <div class="fam_label" onclick="pic_rolldown(\'ID\')">LABEL</div>\
    <img class="toppic_icon" id="ID_img" src="arrow_up.png" onclick="pic_rolldown(\'ID\')"></div> \
    <div id="ID_famframe" class="inframe"></div> \
    </div>'.replace(/ADDEDIT/g, editTag).replace(/ID/g, id).replace(/LABEL/g, famName)

    addTextChild(fams_cont, picsCtrl) // this way I avoid recreating the whole panel each time and making the selection invalid (as opposed to .innerHTML +=)
    
    pics_families[id] = { cubes: []}
    //lastFamAdded = id
    return id
    
}

function picsAddCube(cubeName, id, grpi, editable, intoFam) 
{
    if (grpi == -1)
        grpi = max_grpi + 1
    if (pics_families[intoFam].cubes.length == 6) {
        alert("Can't add more than 6 cubes to a family")
        return;
    }
    id = id.replace(/[-\. ]/g, '_')
    var editClass = '', editCall = 'triggerPicSel'
    if (editable) {
        editClass = "linklike"
        editCall = "triggerCubeEdit"
    }
    var txt = '<div id="ID_inframe" class="piccube">\
    <input class="cube_check_box hidden mycheck" id="ID_ccheck" type="checkbox" onchange="on_cube_check(\'ID\', ID_ccheck.checked, INDEX);"/>\
    <label class="cube_check mycheck_label" id="ID_ccheck_label" for="ID_ccheck" ></label>\
    <span class="EDITCLASS" onclick="EDITCALL(true,INDEX,\'ID\')">LABEL</span>\
    <input class="cube_count" id="ID_ccount" type="number" min="0" step="1" pattern="\d*" oninput="on_cube_count(\'ID\', INDEX)">\
    </div>'.replace(/EDITCLASS/g, editClass).replace(/EDITCALL/g,editCall).replace(/ID/g, id).replace(/LABEL/g, cubeName).replace(/INDEX/g, grpi)
    
    addTextChild( document.getElementById(intoFam + "_famframe"), txt)
    
    pics_families[intoFam].cubes.push( { cid: id, grpi: grpi})
    pics_cubes[id] = { famid: intoFam, picSel:[true,true,true,true,true,true] }
    picFamCheck(id) // check if this changes the family checkbox
    
    if (grpi > max_grpi)
        max_grpi = grpi
}

// update the cube count after a check is changed. v is boolean for the value of the check
// ccount - cube count display
function dispCCount(id, v) {
    var ccount = document.getElementById(id + "_ccount")
    ccount.style.display = (v ? "inline":"none")
    if (v && ccount.value <= 0)
        ccount.value = 1
}

// send the count of an entire cube to c++, v is checke, count is the number, only if v is true
function sendGrpCount(id, v, gind) {
    var ccount = document.getElementById(id + "_ccount")
    if (v)
        setGrpCount(gind, parseInt(ccount.value))
    else
        setGrpCount(gind, 0)
}


function on_fam_check(id, v, doSolve) {
    var fcubes = pics_families[id].cubes;
    for(var i in fcubes) {
        var c = fcubes[i]
        var e = document.getElementById(c.cid + "_ccheck")
        e.checked = v
        e.indeterminate = false
        
        dispCCount(c.cid, v)
        sendGrpCount(c.cid, v, c.grpi)
        resetPicSel(c.cid, v)
    }
    countSelected()
    countSelected()
    if (doSolve) // on inialization select, don't want to do this
        runningRestart()
}

// from C++ on initialization. just need to take care of the checkboxes and count display. the counts are already there
function setFamCheck(id, v) {
    document.getElementById(id + "_fcheck").checked = v
    on_fam_check(id, v, false)
}

function triState(elem, allTrue, allFalse)
{
    elem.indeterminate = false
    if (allTrue) {
        elem.checked = true
    }
    else if (allFalse) {
        elem.checked = false
    }
    else {
        elem.indeterminate = true   
        elem.checked = false
    }
}

function countSelected() {
    var total = 0
    for(var cid in pics_cubes) {
        var ccount = document.getElementById(cid + "_ccount")
        if (ccount.value == "")
            continue
        var sel = pics_cubes[cid].picSel
        var c = 0
        for(var si = 0; si < 6; ++si)
            if (sel[si])
                ++c 
        total += c * parseInt(ccount.value)
    }
    piece_sel_count = total
    writeCounts()
}

function updateShapeFcn(num) {
    pieces_needed = num
    writeCounts()
}

function writeCounts() {
    picNum.innerHTML = "" + pieces_needed + "/" + piece_sel_count
}

// set the state of the family checkbox according the the selection
function picFamCheck(cubeId) {
    var famid = pics_cubes[cubeId].famid
    var fcubes = pics_families[famid].cubes;
    var allTrue = true, allFalse = true
    for(var i in fcubes) {
        var cid = fcubes[i].cid
        var e = document.getElementById(cid + "_ccheck")
        var cv = e.checked
        var itv = e.indeterminate

        allTrue = allTrue && cv && !itv
        allFalse = allFalse && !cv && !itv
    }
    var famCheck = document.getElementById(famid + "_fcheck")
    var famLabel = document.getElementById(famid + "_fcheck_label")
    
    triState(famCheck, allTrue, allFalse)
}

function on_cube_check(id, v, gind) {
    dispCCount(id, v) // also sends to c++
    sendGrpCount(id, v, gind)
    picFamCheck(id)
    resetPicSel(id, v)
    runningRestart()
    countSelected()
}

// set a value to all of the individual booleans
function resetPicSel(id, v)
{
    var picSel = pics_cubes[id].picSel
    for(var i = 0; i < 6; ++i) { // go over the 6 pieces
        picSel[i] = v
    }
    if (currentOpenGrpPics != null && id == currentOpenGrpPics.id) {
        for(var i = 0; i < 6; ++i) { 
            document.getElementById("ipic" + (i+1)).checked = v
        }
    }
}

// id - of the cube
function on_cube_count(id, gind) {
    var ccount = document.getElementById(id + "_ccount")
    var ccheck = document.getElementById(id + "_ccheck")

    var prevCh = ccheck.checked
    var newCh = (parseInt(ccount.value) > 0)
    //console.log("COUNT " + prevCh + " " + newCh)
    if (prevCh != newCh || ccheck.indeterminate) {
        ccheck.checked = newCh
        ccheck.indeterminate = false // changing the checkbox or count resets the individual selection so no indeterminate
        picFamCheck(id)
    }
    setGrpCount(gind, parseInt(ccount.value))
    
    // set the individual booleans
    resetPicSel(id, newCh)
    countSelected()
    runningRestart()
}

// individual piece selected in the ipicWin
function on_pic_check(rel_index, v)
{ // rel_index is the number from the cube - [1-6]
    var picSel = pics_cubes[currentOpenGrpPics.id].picSel
    picSel[rel_index-1] = v
    
    // calc the state of the grp
    var allTrue = true, allFalse = true
    for(var i in picSel) { // go over the 6 pieces
        var iv = picSel[i]
        allTrue = allTrue && iv
        allFalse = allFalse && !iv        
    }
    var ccheck = document.getElementById(currentOpenGrpPics.id + "_ccheck")
    var ccount = document.getElementById(currentOpenGrpPics.id + "_ccount")
    triState(ccheck, allTrue, allFalse)
    
    picFamCheck(currentOpenGrpPics.id)
    dispCCount(currentOpenGrpPics.id, !allFalse) // as long as it's not all turned off, we still want the count to be visible
    var send_count = v ? parseInt(ccount.value) : 0
    setPicCount(currentOpenGrpPics.index, rel_index-1, send_count)
    countSelected()
    runningRestart()
}

// obj is the int handle of the opengl object
function registerTexBind(imgname, obj) {
    //console.log("reg-tex " + imgname + " " + obj)

    var img = document.getElementById(imgname)
    _glBindTexture(GLctx.TEXTURE_2D, obj)
    GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, img)
}

function requestAnim() {
    requestAnimationFrame(animProgress)
}

function animProgress() {
    var again = cpp_draw(0.2);
    if (again)
        requestAnimationFrame(animProgress)
    
}

var enterSlv = false
// called from cpp when the solve is started 
function requestSlvRun() {
    setTimeout(slvRun, 0)
    enterSlv = true
}

function slvRun() {
    if (!enterSlv)
        return
    setTimeout(slvRun, 0)  // pre-schedule the next time to avoid delay
    enterSlv = cpp_slvrun()
}

var lastTms = 0
function sampleTms() {
    var tms = getTms()
    var delta = tms - lastTms
    if (delta != 0)
        stat.innerHTML = "" + delta
    lastTms = tms
}


// opening the family arrow
// v - if not undefined, true means open
function pic_rolldown(id, v) {
    var outframe = document.getElementById(id + '_frame')
    var elem = document.getElementById(id + '_famframe')
    var elemImg = document.getElementById(id + '_img')
    
    if (typeof(v) !== 'undefined' && v == elem.isOpen)
        return;
    
    // roll up anything else that is rolled down
    for(var fid in pics_families) {
        if (fid == id)
            continue
        if (document.getElementById(fid + '_famframe').isOpen) {
            pic_rolldown(fid)
        }
    }
    
    if (elem.isOpen) {
        elem.isOpen = false
        //  elem.style.display = 'none'
        outframe.style.height = "26px";
        elem.style.visibility = 'hidden'
        elem.style.opacity = 0.0

        elemImg.classList.remove('arrowAnimUp')
  
        var newone = elemImg.cloneNode(true); // restart the animation
        elemImg.parentNode.replaceChild(newone, elemImg);
        
        newone.classList.add('arrowAnimDown')
        newone.classList.remove('arrowUpsideDown')
    }
    else {
        elem.isOpen = true
        //  elem.style.display = 'block'
        outframe.style.height = "283px";
        elem.style.visibility = 'visible'
        elem.style.opacity = 1.0
        
        elemImg.classList.remove('arrowAnimDown')

        var newone = elemImg.cloneNode(true);
        elemImg.parentNode.replaceChild(newone, elemImg);

        newone.classList.add('arrowAnimUp')
        newone.classList.add('arrowUpsideDown')
    }
}


function doResize() {
    if (side_ctrl.editMode)
        side_ctrl.style.width = Math.max(window.innerWidth*0.5, 650) + "px"
    mycanvas.width = window.innerWidth - side_ctrl.clientWidth - 16
    mycanvas.height = window.innerHeight - 16
    side_rel.style.height = "" + (window.innerHeight - 220) + "px"
    picEditWin.style.top = (side_ctrl.clientHeight - picEditWin.clientHeight) * 0.5 + "px"
    
    resizeGl(mycanvas.width, mycanvas.height)
    requestAnim()
}

function triggerAdd() {
    if (addingCubeCheck.checked) {
        removingCubeCheck.checked = false
        setEditAction(ACT_ADD) 
    }
    else {
        setEditAction(ACT_NONE)
    }
}
function triggerRemove() {
    if (removingCubeCheck.checked) {
        addingCubeCheck.checked = false
        setEditAction(ACT_REMOVE)
    }
    else {
        setEditAction(ACT_NONE)
    }

}

function eventStopProp(e) {
    e.stopPropagation()
}

function triggerAbout(v, ev) {
    aboutBtn.checked = v
    if (v) {
        aboutBack.style.display = "inline"
    }
    else {
        aboutClick(ev.clientX, ev.clientY)
        aboutBack.style.display = "none"
    }
    
    aboutWin.onclick = eventStopProp
}


var scratchArr = [] // used from cpp by serialize, deserialize

function bufferToBase64(buf) {
    var binstr = Array.prototype.map.call(buf, function (ch) {
        return String.fromCharCode(ch);
    }).join('');
    return btoa(binstr);
}

function base64ToBuffer(base64) {
    try {
        var binstr = atob(base64);
        var buf = new Uint8Array(binstr.length);
        Array.prototype.forEach.call(binstr, function (ch, i) {
          buf[i] = ch.charCodeAt(0);
        });
        return buf;
    } catch(err) {
        return "";
    }
}

function triggerUrl() {
    if (urlBack.style.visibility == "visible") {
        urlBack.style.visibility = "hidden"
        return
    }
    scratchArr = []
    serializeCurrent()
    var b = bufferToBase64(scratchArr)
    console.log(b)
    urlBack.style.visibility = "visible"
    var url = window.location.toString()
    var qmark = url.indexOf('?')
    if (qmark > 0)
        url = url.substr(0, qmark)
    urlEdit.value = url + '?l=' + b
    urlEdit.select()
    
    urlPopup.onclick = eventStopProp // click in the window should not go to urlBack and dismiss it
}

//loadUrl("AQoAAAgAQAAAAARAAQAQAAEAEAQAAQAgCARBHXRogCOG8YptBGEKWzg=")
function loadUrl(b) {
    var srchAt = b.indexOf('?l=')
    if (srchAt != -1)
        b = b.substr(srchAt + 3)
    if (b.length == 0)
        return;
    scratchArr = base64ToBuffer(b)
    deserializeAndLoad(scratchArr.length)
}

function urlEditChanged() {
    loadUrl(urlEdit.value)
    urlBack.style.visibility = "hidden"
}

function triggerAddFam() {
    var famName = window.prompt("Family Name?","");
    if (famName == null)
        return
    picsAddFamily(famName, famName, true)
}

function triggerAddCube(intoFam) {
    var cubeName = window.prompt("Cube Name?","");
    if (cubeName == null || cubeName == "")
        return
    pic_rolldown(intoFam, true)
    picsAddCube(cubeName, cubeName, -1, true, intoFam)
}

var IPIC_TSZ = 15

function eventInElement(ev, elem)
{
    var elemRect = elem.getBoundingClientRect()
    var cx = ev.clientX, cy = ev.clientY
    if (cx > elemRect.left && cx < elemRect.right && cy > elemRect.top && cy < elemRect.bottom)
        return true
    return false
}

function triggerPicSel(v, index, id) 
{
    ipicWin.style.visibility = 'visible'
    var inframe = document.getElementById(id + "_inframe")
    var rect = inframe.getBoundingClientRect()
    ipicWin.style.top = rect.top + "px"
    readCubeToEditor(index)
    jsgrp = defaultJsGrp()
    paintCubeSpec(ipicCanvas, ipicCanvas.getContext('2d'), IPIC_TSZ)
    currentOpenGrpPics = {id:id, index:index}
    
    // set the current state values
    for(var i = 0;i < 6; ++i) {
        document.getElementById("ipic" + (i+1)).checked = pics_cubes[currentOpenGrpPics.id].picSel[i]
    }
    
    var mouseHandler = function(e) {
        if (eventInElement(e, ipicWin) || eventInElement(e, inframe))
            return true; // inside the ipicWin, let it do its jon
        // otherwise, dismiss the ipinWin
        ipicWin.style.visibility = 'hidden'
        document.removeEventListener("mousedown", mouseHandler)
        currentOpenGrpPics = null
        return false
    }
    document.addEventListener("mousedown", mouseHandler)
}

var countSlvs = 0 // number of solutions in the document, same as m_slvs.size()
var nCurSlv = 0  // same as m_nCurSlv from CubeDocBase
var isRunning = false; // same as fRunning in RunContext

// from c++
function slvStat(cur, sz) {
    nCurSlv = cur
    countSlvs = sz
    prevBtn.setAttribute('disabled', nCurSlv <= 0)
    slvNum.innerHTML = "" + (cur+1) + "/" + sz
    nextBtnIn.style.visibility = (nCurSlv < countSlvs - 1)?'hidden':'visible'

}
// from c++
function updateIsRunning(v) {
    if (v == isRunning)
        return;
    isRunning = v;    
    if (isRunning) {
        nextBtnIn.style.backgroundImage = "url(gears/gear_anim.gif)"
        nextBtnIn2.style.backgroundImage = "url(pause.png)"
    }
    else {
        nextBtnIn.style.backgroundImage = "url(gears/g1_lightg.png)" 
        nextBtnIn2.style.backgroundImage = "url(forward_arrow.png)"
    }
}

function triggerPrev()
{
    if (isRunning) {
        stopSlvRun()
    }
    if (prevBtn.getAttribute('disabled') == 'true')
        return;
    goToSlv(nCurSlv - 1) // calls back to slvStat
}

function triggerNext()
{
    if (isRunning) {
        stopSlvRun()
        return;
    }
    if (nCurSlv < countSlvs - 1)
        goToSlv(nCurSlv + 1)
    else
        newRestart(NR_KEEP_PREV)
}

var shscratch = ""
function sha1(txt) {
    var x = new jsSHA('SHA-1', 'TEXT', {numRounds:3})
    x.update(txt)
    return x.getHash('HEX')
}

function passPrompt(oninput) {
    addTextChild(body, '<div id="keyCenter" style="position: absolute; left: 50%; top:0">\
        <div id="keyBack" style="position: relative; left: -50%;"><input id="inKey" type="password"/></div></div>')
    inKey.focus()
    inKey.onchange = function() { oninput(inKey.value); shscratch=""; body.removeChild(keyCenter) }
}

function enableKey() {
    addTextChild(side_rel, '<label id="addFamBtn" class="sc-btn sc-keyed" onclick="triggerAddFam()"/><span id="addFamBtnIn"></span></label>')
    
    addTextChild(side_ctrl, '<label id="exportBtn" class="sc-btn sc-keyed" title="Export" onclick="triggerExport()">\
        <span style="background: url(export.png) center no-repeat; display: inline-block; width: 30px; height: 30px;"></span></label>')
}

var expScratchObj = null, expScratchMtl = null, expScratchName = null  // used by exportModel
function triggerExport() {
   if (exportBack.style.visibility == "visible") {
        exportBack.style.visibility = "hidden"
        return
    }
    exportBack.style.visibility = "visible"

    exportModel()
    
    function setDownload(file, elem, ext) {
        var blob = new Blob([file], {type: "octet/stream"})
        var url = window.URL.createObjectURL(blob)
        elem.href = url
        elem.innerHTML = expScratchName + ext
        elem.download = expScratchName + ext
        return url
    }
    
    var objUrl = setDownload(expScratchObj, linkObj, ".obj")
    var mtlUrl = setDownload(expScratchMtl, linkMtl, ".mtl")
    
    exportPopup.onclick = eventStopProp 
}

function hideError() {
    errNotify.style.opacity = 0
    errBack.style.visibility = 'hidden'
    errBack.style.transitionDelay = "1s";
}
function notifyError(str)
{
    errNotify.style.opacity = 1
    errBack.style.visibility = 'visible'
    errBack.style.transitionDelay = "0s";
    errNotify.innerHTML = str;
    /*setTimeout(function() {
        errBack.style.visibility = 'hidden'
    }, 7000)*/
}


//--------------------------------------------------------------------------------------

var cube = [
   // 0,1,2,3,4,5,6,7,8,9,1011121314
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 0
    [ 0,1,1,1,1,1,0,0,0,0,0,0,0,0,0 ], // 1
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 2
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 3
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 4
    [ 0,1,1,1,1,1,4,4,4,6,6,6,6,6,0 ], // 5
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 6
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 7
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 8
    [ 0,0,0,0,0,0,0,0,0,6,6,6,6,6,0 ], // 9
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 10
]


var EDIT_TSZ = 30  // size in pixels of a tooth
var DRAW_COLOR = 0
var DRAW_PROFI = 2
var DRAW_MARBLE = 4
var DRAW_TEX = 0x14

var EDIT_MARGIN = 5

var loadedImg = null  // the image reference being displayed, the image loaded
var origLoadedImg = null // original before rotation
var fileOpenedButNotUploaded = false  // used for enable of the upload button
var lastFile = null // file object of the last file that was selected by the user

var jsgrp = null; // parameters of the currently edited cube

function drawLine(ctx, x, y, w, h) {
    ctx.beginPath()
    ctx.moveTo(x, y)
    ctx.lineTo(x + w, y + h);
    ctx.stroke();
}

function paintCube() {
    paintCubeSpec(editCanvas, editCtx, EDIT_TSZ)
}

function paintCubeSpec(cnvs, ctx, TSZ)
{
    ctx.fillStyle = '#fff'
    ctx.fillRect(0, 0, cnvs.width, cnvs.height)
    
    switch(jsgrp.drawType) {
    case DRAW_TEX:
        if (loadedImg) 
        {
            ctx.fillStyle = '#'+jsgrp.colorBack.colors.HEX
            ctx.fillRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ) // need to show up below transparent pixels
            
            var cwidth = 15*TSZ 
            var cheight = cwidth * loadedImg.height / loadedImg.width  // maintain same aspect ratio as the image
            ctx.drawImage(loadedImg, 0,0, loadedImg.width, loadedImg.height, 
                                       jsgrp.imgOffset.x + EDIT_MARGIN, jsgrp.imgOffset.y + EDIT_MARGIN, cwidth*jsgrp.imgZoom, cheight*jsgrp.imgZoom)
        }
        break
    case DRAW_PROFI:
    case DRAW_MARBLE:
        if (!current_src) // indicates colored_tex is on
            throw "missing current_src"
        ctx.putImageData(colored_tex, EDIT_MARGIN, EDIT_MARGIN)
        break
    case DRAW_COLOR:    
        ctx.fillStyle = '#'+jsgrp.colorBack.colors.HEX
        ctx.fillRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ)
        break
    }
    
    ctx.strokeStyle = 'black'
    ctx.lineWidth = 1
    
    // frame
    ctx.strokeRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ)

    ctx.strokeStyle = isColorsBlack(editBlackSel.value, jsgrp.colorBack.colors, jsgrp.colorFront.colors, jsgrp.drawType) ? 'white':'black'
    
    for(var x = 0; x < 15; ++x) {
        for(var y = 0; y < 11; ++y) {
            var v = cube[y][x]
            if (y < 10 && x < 14) {
                if (v != cube[y+1][x]) {
                    drawLine(ctx, x * TSZ + EDIT_MARGIN, y * TSZ + TSZ + EDIT_MARGIN, TSZ, 0)
                }
                if (v != cube[y][x+1]) {
                    drawLine(ctx, x * TSZ + TSZ + EDIT_MARGIN, y * TSZ + EDIT_MARGIN, 0, TSZ)
                }                
            }
        }
    }
}

function setGlTexture() 
{
    var obj = getCubeTextureHandle(editingCubeId, loadedImg.width, loadedImg.height)
    if (obj == 0)
        return
    console.log("setting img to texture " + obj)
    _glBindTexture(GLctx.TEXTURE_2D, obj)
    GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, loadedImg)
    
    // need to setTexCoord here since the width and height might have changed and we need to recalculate them
    sendTexCoord()
    paintCube()
}


// called with the default image on initialization
function loadTexImage(url, type, opt)
{   
    if (!opt) // keepOrig, ondone, onerr, 
        opt = {}
    if (url.length == 0)
        return
    var onload = function() {
       // loadedImg.loadedOk = true
        if (newImg.width == 1 && newImg.height == 1) 
        { // indicates its an SVG
            // get it again, now as a blob (should come from cache and should not fail)
            var oReq = new XMLHttpRequest();
            oReq.open("GET", url, true);
            oReq.responseType = "arraybuffer";
            oReq.onload = function(oEvent) 
            {
                var blob = new Blob([new Uint8Array(oReq.response, minimalPng.length)], {type: "image/svg+xml"});
                loadTexImageBlob(blob, opt)
            };
            oReq.send()
            return
        }
        
        // if an SVG is smaller than 1500px, draw it on the scratch canvas to scale it and take that as the image
        var f = 1500 / newImg.width
        if (type == "image/svg+xml" && f > 1) 
        {
            canvas_scratch.width = 1500
            canvas_scratch.height = newImg.height/newImg.width*1500
            var ctx = canvas_scratch.getContext('2d')
            ctx.drawImage(newImg, 0, 0, canvas_scratch.width, canvas_scratch.height)
            var durl = canvas_scratch.toDataURL("image/png")
            loadTexImage(durl, "image/png", opt)            
            return
        }
        
        if (!opt.noCommit) {
            loadedImg = newImg // switch to the new image
            setGlTexture()
        }
        if (!opt.keepOrig) // default is false, don't keep the original (only needed on rotate)
            origLoadedImg = newImg
        if (opt.ondone)
            opt.ondone()
    }

    var newImg = new Image()

    newImg.onload = onload
    newImg.onerror = function(e) {
        if (opt.onerr)
            opt.onerr()
        console.log("IMAGE-LOAD-ERR")
        resetErrMsg("Failed loading image")
    }
    newImg.crossOrigin = ''
    newImg.src = url
    
}

var editingCubeId = -1
var src_marble = null, src_profi = null // ImageData of the B&W images
var current_src = null // select between src_marble or src_profi or null
var colored_tex = null // resulting colored image that will be displayed (tinted in makeColoredTex)

function makeColoredTex()
{
    if (current_src == null)
        return
    var dst = colored_tex.data
    var src = current_src.data
    var fr = jsgrp.colorFront.colors.rgb.r, fg = jsgrp.colorFront.colors.rgb.g, fb = jsgrp.colorFront.colors.rgb.b
    var br = jsgrp.colorBack.colors.rgb.r, bg = jsgrp.colorBack.colors.rgb.g, bb = jsgrp.colorBack.colors.rgb.b
    for (var i = 0; i < dst.length; i += 4) 
    {
        var g = src[i]
        var rg = 255-g
        dst[i]     = br * g + fr * rg  // red
        dst[i + 1] = bg * g + fg * rg // green
        dst[i + 2] = bb * g + fb * rg // blue
        dst[i + 3] = 255;
    }
}


function updateColorWidget(c, ed, def, idx, skipText) 
// color object to update, edit tag to update, default value, index in pickers (0=back, 1=front), skipText if we just update the text
{
    if (isNaN(c.colors.rgb.r)) {  // grp had an empty string for color, take the default
        if (typeof(def) === 'undefined')
            return
        c.setColor(def)
    }
    if (!skipText)    
        ed.value = '#' + c.colors.HEX
    else
        ed.beingEditedNow = true
    colorPickCfg.init(ed, c.colors);
    if (window.jsColorPicker.colorPickers[idx]) 
    {// set the picker popup to the right position according to the color
        window.jsColorPicker.colorPickers[idx].setColor(c.colors.HEX, undefined, undefined, true) // forceRender
    }
    
}

function changedColFocus(ed, v, idx) {
    ed.beingEditedNow = v
    // selects the window of the picker
    window.jsColorPicker.colorPickers[idx].nodes.colorPicker.onmousedown = function() {
        // simulate out of focus in case we just edited the text and are now moving the knob
        ed.beingEditedNow = false
    }
}

var COLOR_BACK_DEFAULT = "#ffffff"
var COLOR_FRONT_DEFAULT = "#808080"

function defaultJsGrp() {
    return { colorBack: new Colors({color:COLOR_BACK_DEFAULT}),
             colorFront: new Colors({color:COLOR_FRONT_DEFAULT}),
             drawType: DRAW_COLOR,
             rotAngle: 0,
             lastUrl: null,
             imgOffset: {x:0, y:0},
             imgZoom: 1
             }  
}

function triggerCubeEdit(v, cubeId) // cube link pressed or Done pressed
{
    if (v) 
    {
        editBack.style.display = "inline" // make it visible
        side_ctrl.editMode = true // for resize
        doResize()
        editActionPiecesCheck.checked = true
        editActionMoveCheck.checked = false

        editCanvas.height = 11*EDIT_TSZ + 2*EDIT_MARGIN
        editCanvas.width = 15*EDIT_TSZ + 2*EDIT_MARGIN
        
        setEditAction(ACT_NONE) // prevent hovering on the cube from editing

        editingCubeId = cubeId
        stackState(0) // push and clear
        conf(false) // make it not randomized so that the solution would be more or less the same
        
        readCubeToEditor(editingCubeId, "ab1255a96529b5522b")  // from grp or default to the editor
        readCubeFromEditor(editingCubeId) // first update of the grp pieces (if this is the first time)

        setGrpCount(editingCubeId, 1) // set it to be selected, need to be here after the parts were added from the editor

        jsgrp = defaultJsGrp()      
        
        // read from grp color, drawType, black select
        textureParamToEditor(editingCubeId);
        editFileName.value = jsgrp.lastUrl
        
        switch(jsgrp.drawType) { // needs to be before doing any paintCube because that would fail about current_src
        case DRAW_TEX:    editFillTextureRadio.checked = true; break;
        case DRAW_PROFI:  editFillMixRadio.checked = true; break
        case DRAW_MARBLE: editFillMarbleRadio.checked = true; break
        case DRAW_COLOR:  editFillColorRadio.checked = true;  break    
        }
        
        updateColorWidget(jsgrp.colorBack, editBackColor, COLOR_BACK_DEFAULT, 0)
        updateColorWidget(jsgrp.colorFront, editFrontColor, COLOR_FRONT_DEFAULT, 1)
       
        
        updateForDrawType() // needs to be after the setting of the colors (going to mix them) but before loadTexImage
        
        // something to show in the mean time while the url is downloading
        // do the texture loading anyway no depending on drawType since we might return to textur any time
        loadedImg = blank_tex
        origLoadedImg = loadedImg 
        setGlTexture()            
        var mtype = mimeTypeByExt(jsgrp.lastUrl)
        loadTexImage(jsgrp.lastUrl, mtype, { noCommit: true, ondone: function() { // lastUrl was set by the above call
            makeTransformedImg() // takes rotAngle, sets the image and gl instead of loadTexImage which has noCommit
        }}) 
            
        
        if (editBlackSel.value == '')
            editBlackSel.value = 'auto'
            
        // read from grp image offset and zoom
        sendTexCoord() // need to actually create the texture coordinates from the imgOffset and imgZoom
        updateZoomValue() 
        
        // transfer the marble,profi images to the canvase so they could be accessed when the time comes
        if (!colored_tex) { // happen only in the first time the dialog opens  - TBD needs to be HIGHER
            var run_image = function(img) {
                canvas_scratch.width = 15*EDIT_TSZ
                canvas_scratch.height = 11*EDIT_TSZ
                var ctx = canvas_scratch.getContext('2d')
                ctx.drawImage(img, 0,0)
                return ctx.getImageData(0,0, canvas_scratch.width, canvas_scratch.height)
            }
            src_marble = run_image(edit_marble)
            src_profi = run_image(edit_profi)
            colored_tex = editCtx.createImageData(15*EDIT_TSZ, 11*EDIT_TSZ)
        }
        
        paintCube()   
        newRestart(0) // don't keep prev       
    }
    else 
    {
        if (!uploadDisabled()) {
            triggerEditUpload(function() {
                triggerCubeEdit(false);
            })
            return
        }
        readCubeFromEditor(editingCubeId)
        editingCubeId = -1
        jsgrp = null
        
        freeMeshAllocator()
        conf(true)  // revert back to randomized
        stackState(1) // pop last

        editBack.style.display = "none"
        side_ctrl.style.width = "230px"
        side_ctrl.editMode = false
        doResize()
        if (addingCubeCheck.checked)
            setEditAction(ACT_ADD)
        else if (removingCubeCheck.checked)
            setEditAction(ACT_REMOVE)
    }
}

var lastEditDrag = null
function handleEditCanvasDown(event)
{
    lastEditDrag = {x:event.clientX, y:event.clientY}
}

function handleEditCanvasMove(event)
{
    var curDrag = lastEditDrag
    lastEditDrag = null // manage move selection
    if (!editActionMoveCheck.checked)
        return true
    if (event.buttons != 1 || curDrag == null) // left mouse button
        return true

        
    jsgrp.imgOffset.x += event.clientX - curDrag.x
    jsgrp.imgOffset.y += event.clientY - curDrag.y
    lastEditDrag = {x:event.clientX, y:event.clientY}
    
    paintCube()
    sendTexCoord()
    return false
}

function handleEditCanvasClick(event)
{
    if (editActionPiecesCheck.checked)
        checkToothClick(event)
}
 
var toothScratch = null
 
function checkToothClick(event)
{ 
    var rect = editCanvas.getBoundingClientRect()
    var x = Math.trunc((event.clientX - rect.left - EDIT_MARGIN)/EDIT_TSZ), y = Math.trunc((event.clientY - rect.top - EDIT_MARGIN)/EDIT_TSZ)
    //console.log(x + " " + y)
    
    var hasSameNei = function(v, x, y) { // don't allow isolated tooth of a color
        return cube[y][x-1] == v || cube[y][x+1] == v || cube[y-1][x] == v || cube[y+1][x] == v
    }
    var didSomething = false;
    toothScratch = []
    getToothPossibilities(x, y); //  writes toothScratch
    if (toothScratch.length == 0) // didn't find
        return;
    do {
        cube[y][x] = (cube[y][x] + 1) % 7
    } while(!toothScratch.includes(cube[y][x]) || !hasSameNei(cube[y][x], x, y))

    paintCube()
    readCubeFromEditor(editingCubeId)
    
    newRestart(0)
}

function triggerEditDone()
{
    if (editingCubeId == -1)
        throw "Unexpected cube-id"

    triggerCubeEdit(false) // remove the dialog
}



// callback from color selector
function changeColor(colors, mode, options) 
{
    if (options.input.value == options.input.prevValue)
        return
    options.input.prevValue = options.input.value
    if (options.input == editBackColor)
        jsgrp.colorBack.setColor(colors.HEX)
    else if (options.input == editFrontColor)
        jsgrp.colorFront.setColor(colors.HEX)
        
    makeColoredTex()   
    paintCube()
    sentTexParam()
}

function colKey(ev, which)
{
    if (ev.keyCode == 13) {// enter
        changedColorText(which, false) // skipText false makes the edit change the text to hex
    }
}

function changedColorText(which, skipText)
{
    if (which == 0) {
        if (editBackColor.value == "")
            return
        jsgrp.colorBack.setColor(editBackColor.value)
        updateColorWidget(jsgrp.colorBack, editBackColor, undefined, 0, skipText)
    }
    else {
        if (editFrontColor.value == "")
            return    
        jsgrp.colorFront.setColor(editFrontColor.value)
        updateColorWidget(jsgrp.colorFront, editFrontColor, undefined, 1, skipText)
    }
}

function isColorsBlack(linesSel, backColors, frontColors, drawType) {
    if (linesSel == 'white')
        return true
    if (linesSel == 'normal')
        return false
    // 'auto'    
    var bl = backColors.rgbaMixWhite.luminance
    var fl = frontColors.rgbaMixWhite.luminance

    // in case of textured draw, I assume the back color represents the piece color
    if (drawType == DRAW_COLOR || drawType == DRAW_TEX)
        return bl < 0.05
    else if (drawType == DRAW_MARBLE || drawType == DRAW_PROFI)
        return (bl < 0.1 && fl < 0.1) || bl < 0.05 || fl < 0.05 // either one of them is really dark or both kinda dark
    return false // shouldn't happen
}

function sentTexParam() {
    var bc = jsgrp.colorBack.colors
    var fc = jsgrp.colorFront.colors
    textureParamCube(editingCubeId, jsgrp.drawType, 
                     bc.rgb.r, bc.rgb.g, bc.rgb.b, 
                     fc.rgb.r, fc.rgb.g, fc.rgb.b, 
                     isColorsBlack(editBlackSel.value, bc, fc, jsgrp.drawType), 
                     bc.HEX, fc.HEX, editBlackSel.value, jsgrp.rotAngle, jsgrp.lastUrl) // things saved for the editor
}

// a minimal 1x1 SVG file 
var minimalPng = new Uint8Array([
	0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
	0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
	0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
	0x13, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0x62, 0xF8, 0xFF, 0xFF, 0x3F,
	0x03, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x08, 0xFC, 0x02, 0xFE,
	0xD3, 0xA5, 0x75, 0x61, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44,
	0xAE, 0x42, 0x60, 0x82])
    
// imgur doesn't support svg so I hide the svg in a png by simply concatenating it to its end
function encodePng(ba)
{
    var tmp = new Uint8Array(ba.byteLength + minimalPng.length)
    tmp.set(minimalPng, 0)
    tmp.set(new Uint8Array(ba), minimalPng.length)
    return tmp
}



function triggerEditUpload(ondone)
{
    if (uploadDisabled())
        return;
    resetErrMsg()
    var file = lastFile
    var reader = new FileReader();
    reader.onload = function(e) 
    { 
        var req = new XMLHttpRequest();
        
        req.onload = function () {
            console.log(req.responseText)
            var re = JSON.parse(req.responseText)
            if (re.success != true || re.status != 200) {
                resetErrMsg("Failed upload, " + re.status)
                return
            }
            editFileName.value = re.data.link
            jsgrp.lastUrl = re.data.link
            sentTexParam() // save that url
            editUploadProgress.style.visibility = "hidden"
            fileOpenedButNotUploaded = false
            updateUploadBtnDisabled()
            if (ondone)
                ondone()
        }
        req.onprogress = function(e) {
            if (e.total == 0)
                return
            var percentComplete = (e.loaded / e.total)*100; 
            //console.log(percentComplete + "  " + e.loaded + "/" + e.total)
            editUploadProgress.value = percentComplete
        }
        if (req.upload) // in chrome there's a different progress listener
            req.upload.onprogress = req.onprogress
        req.onerror = function(e) {
            console.log(e)
            editUploadProgress.style.visibility = "hidden"
        }
    
        req.open("POST", 'https://api.imgur.com/3/image', true)
        req.setRequestHeader("Authorization", "Client-ID 559401233d3e1e6")
        req.setRequestHeader("Accept", 'application/json')
        req.setRequestHeader("Content-Type", file.type)
        
        var buf = e.target.result
        if (file.type == "image/svg+xml")
            buf = encodePng(buf)
        req.send(buf)
    
    }
    reader.onerror = function(e) {
        console.log("READER-ERR" + e)
        resetErrMsg("Failed Upload!")
    }
    
    editUploadProgress.value = 0
    editUploadProgress.style.visibility = "visible"
    reader.readAsArrayBuffer(file)


    
    //loadTexImage("http://localhost:8000/emscripten/test_texture3.png")
    //loadTexImage("http://i.imgur.com/dPY5gPe.png") 
    //loadTexImage("http://i.imgur.com/gIcxWPI.png")    // transparent
    
    // imgur.com/gDXDY67.png  - noise
    //http://i.imgur.com/P1ecEyR.png  - svg plus
    //http://i.imgur.com/Yjr8XdH.png - svg too small
    
    //loadTexImage(blank_tex)
}


function loadTexImageBlob(blob, opt)
{    
    var reader = new FileReader();
    reader.onload = function(e) { 
        loadTexImage(e.target.result, blob.type, opt) 
    }
    reader.onerror = function(e) {
        console.log(e)
    }
    reader.readAsDataURL(blob); // read as data URL since we want to put it in an img src
}

function triggerFileChanged()
{
    if (editFileInput.files.length == 0)
        return
    var file = editFileInput.files[0]
    editFileInput.value = null
    lastFile = file

    loadTexImageBlob(file, { ondone:function() {
        // new image from the user - reset parameters
        jsgrp.imgOffset = {x:0, y:0}
        jsgrp.imgZoom = 1
        jsgrp.rotAngle = 0 
        updateZoomValue()
        paintCube()
        sendTexCoord()
    }})
    
    editFileName.value = file.name
    fileOpenedButNotUploaded = true

    updateUploadBtnDisabled()
    return false
}


function sendTexCoord()
{
    if (loadedImg === null)
        return

    readCubeTexCoord(editingCubeId, jsgrp.imgOffset.x, jsgrp.imgOffset.y, jsgrp.imgZoom, loadedImg.width, loadedImg.height, EDIT_TSZ) 
}

function triggerAction(bpr)
{
    if (bpr == 1) {
        if (editActionPiecesCheck.checked) {
            editActionMoveCheck.checked = false
        }
    }
    else {
        if (editActionMoveCheck.checked) {
            editActionPiecesCheck.checked = false
        }
    }
}

function changeImgZoom(widget, v)
{
    if (widget == 1) { // slider changed
        editZoomText.value = v + "%"
    }
    else { // edit changed
        editZoomSlider.value = v
    }
    jsgrp.imgZoom = v / 100.0
    
    paintCube()
    sendTexCoord()
}

function uploadDisabled() {
    return jsgrp.drawType != DRAW_TEX || !lastFile || !fileOpenedButNotUploaded
}

function updateUploadBtnDisabled() {
    var d = uploadDisabled()
    editUploadBtn.setAttribute("disabled", d) // custom attribute
}

function updateTexDisabledWidgets()
{
    var d = jsgrp.drawType != DRAW_TEX
    editFileButton.disabled = d
    editFileInput.disabled = d
    editFileName.disabled = d

    updateUploadBtnDisabled(d)
    editActionMoveCheck.disabled = d
    if (editActionMoveCheck.checked) {
        editActionMoveCheck.checked = false
        editActionPiecesCheck.checked = true
    }

    editZoomSlider.disabled = d
    editZoomText.disabled = d
    
    editRotR.setAttribute("disabled", d)
    editRotL.setAttribute("disabled", d)
}

function updateZoomValue() {
    editZoomSlider.value = jsgrp.imgZoom * 100
    editZoomText.value = Math.round(jsgrp.imgZoom * 100) + "%"
}

function changeFillSelect(dtype)
{
    if (jsgrp.drawType == dtype)
        return;
    jsgrp.drawType = dtype
    sentTexParam() // send it to grp first so that the following will be able to take care of the tex-coordinates
    updateForDrawType()

    resetErrMsg() // don't want this to stick around after we changed the type
    paintCube()
    if (jsgrp.drawType == DRAW_TEX)
        newRestart(0)  // setting individual half need a new solution with all textures out
}
    
function updateForDrawType()
{    
    switch(jsgrp.drawType) 
    {
    case DRAW_PROFI: current_src = src_profi; break
    case DRAW_MARBLE: current_src = src_marble; break
    case DRAW_COLOR:
    case DRAW_TEX:   current_src = null; break
    }
    updateTexDisabledWidgets()
    makeColoredTex()
}

function triggerBlackSel()
{
    paintCube()
    sentTexParam()
}

function mimeTypeByExt(fileName) {
    var ext = fileName.substr(fileName.lastIndexOf('.') + 1).toLowerCase();
    var type = ""
    switch (ext) {
    case "png": return "image/png";
    case "jpg": 
    case "jpeg": return "image/jpeg"; 
    case "svg": return "image/svg+xml"; 
    }
    return ""
}

function resetErrMsg(msg) {
    if (msg)
        editErrMsg.innerHTML = msg
    else
        editErrMsg.innerHTML = ""
}

function triggerEditChanged()
{
    var fileName = editFileName.value
    var lowName = fileName.toLowerCase()
    if (!lowName.startsWith("http://") && !lowName.startsWith("https://")) {
        resetErrMsg("Not a well formed URL")
        return
    }
    resetErrMsg()
    var type = mimeTypeByExt(fileName)
    loadTexImage(fileName, type, {ondone:function() {
        jsgrp.lastUrl = fileName // on success, save the entered url
        sentTexParam() // save url
    }, 
    onerr:function() {
        resetErrMsg("Failed Loading")
    }})
    lastFile = null
    updateUploadBtnDisabled()
}



function triggerRotate(dir)
{
    jsgrp.rotAngle = (jsgrp.rotAngle + dir + 4) % 4; // don't allow it to go negative
    sentTexParam()
    makeTransformedImg()
}
    
function makeTransformedImg()
{    
    if (jsgrp.rotAngle == 0) {
        loadedImg = origLoadedImg
        setGlTexture()
        return
    }
    
    if (jsgrp.rotAngle == 1 || jsgrp.rotAngle == 3) {
        canvas_scratch.width = origLoadedImg.height
        canvas_scratch.height = origLoadedImg.width
    }
    else {
        canvas_scratch.width = origLoadedImg.width
        canvas_scratch.height = origLoadedImg.height
    }
    var ctx = canvas_scratch.getContext('2d')
    ctx.setTransform(1,0, 0,1, 0,0)
    ctx.translate(canvas_scratch.width/2, canvas_scratch.height/2);
    ctx.rotate(jsgrp.rotAngle * Math.PI/2);
    ctx.drawImage(origLoadedImg, -origLoadedImg.width/2, -origLoadedImg.height/2);
    
    var url = canvas_scratch.toDataURL("image/png")
    loadTexImage(url, "image/png", {keepOrig:true})

}
    
</script>
<script src="js_main.js"></script>
<style>
body {
    margin: 0;
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
     user-select: none;
    background: #b2b2b2; 
    font-family: Verdana;
}
#mycanvas {
    margin: 8px 0 0 8px;

}
#errNotify {
    width: 50%;
    margin: 50px auto 0 auto;
    text-align: center;
    background: linear-gradient(to bottom, #ffd1d1, #ffbcbc);
    padding: 7px;
    border-radius: 6px;
    border: #d10303 solid 2px;
    transition: opacity 0.3s linear;
    opacity: 0;    
}
#errBack {
    transition:visibility 0s linear 0.3s;
    visibility: hidden;
    position: absolute;
    top: 0;
    width: 100%;
}

#canvasCont {
    position: relative;
    display: inline-block;

}

#side_ctrl {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 230px;
    background: #cbcfff;
    margin-top: 8px;
    margin-bottom: 8px;
    overflow:hidden;
    border-radius: 8px 0 0 8px;
}
.toppic {
    margin: 5px 5px 5px 7px;
    background: #eeeeff;
    font-family: Verdana;
    padding: 4px;
    border-radius: 5px;
    transition: height 0.2s ease-in-out;
    height: 26px;
    
}
.in_rel {
    position:relative; 
    width:100%; 
    top: 100px;
    bottom: 20px;
    overflow: hidden;
}
.toppic_icon {
    float: right;
    padding: 3px 0 3px 0;
}
.inframe {
    display: block;
    visibility: hidden;
    position: relative;
    opacity: 0;
    transition: all 0.2s ease-in-out;
}
.cube_count {
    display: none; /* start retracted */
}
.piccube {
    height: 26px;
    line-height: 26px; /* vertical align */
    background: #ffffff;
    padding: 6px;
    margin:4px;
    
    border-radius: 5px;
}
.famtitle {
    height: 26px;
    line-height: 26px;
}

@keyframes rotate180 {
    0%   {transform: rotate(0deg);}
    100% {transform: rotate(180deg);}
}
.arrowAnimUp {
    animation-name: rotate180;
    animation-duration: 0.2s;
}
.arrowAnimDown {
    animation-name: rotate180;
    animation-duration: 0.2s;
    animation-direction: reverse;
}
.arrowUpsideDown {
    transform: rotate(180deg);
}
.fam_check {
    width: 17px;
    height: 17px;
    margin: -4px 4px 0 2px;
    vertical-align: middle;
}
.fam_label {
    display:inline-block;
    width: 160px;
}
.cube_check {
    width: 17px;
    height: 17px;
    vertical-align: middle;
    margin: -4px 7px 0 0
}
.cube_count {
    position: absolute;
    right: 12px;
    width: 50px;
    height: 17px;
    padding: 2px 0 2px 0;
    text-align: center;
}
#stat {
    position: absolute;
    bottom: 8px;
    left: 8px;
}

.mycheck + .mycheck_label {
    background: url(check_none.png) no-repeat;
    display: inline-block;
}
.mycheck:checked + .mycheck_label {
    background-image: url(check_checked.png);
}
.mycheck:indeterminate + .mycheck_label {
    background-image: url(check_int.png);
}

/*------------------------------------------------------------*/
.hidden {
    position:absolute;
    z-index:-2;
    }
.sc-btn {
  display: inline-block;
  position: absolute;

  font-family: "Helvetica Neue", "Helvetica", sans-serif;

  border-radius: 0.4em;

  box-shadow: inset rgba(0, 0, 0, 0.1) 0px -0.15em 0px, inset rgba(255, 255, 255, 0.2) 0px 0.15em 0px, rgba(0, 0, 0, 0.3) 0px 0.1em 0.3em;
  text-align: center;
  cursor: pointer;
  overflow: hidden; 
  
  color: #222;
  text-shadow: rgba(127, 127, 127, 0.4) 0 1px 0;
  background-color: #ebebeb;
  background-image: linear-gradient(to bottom, white, #ebebeb);   
  
  width: 100px;
  height: 40px;
  line-height: 40px;
  margin: 7px;
  outline:none;  /* no focus outline */
  font-size:110%;
}

.sc-btn:hover {
  color: #222;
  background-image: linear-gradient(to bottom, white, #d2d2d2);
  background-color: #fdfdfd;   
}

.sc-btn:active {
    box-shadow: rgba(255, 255, 255, 0.2) 0 0.1em 0, inset rgba(0, 0, 0, 0.3) 0px 0.25em 1em; 
    color: #fff;
    background-color: #dfdfdf;
    background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
}
.sc-btn:checked  {

  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
}
.sc-btn:disabled {
   color: #ddd;
}

.sc-btn[disabled="true"] {
    box-shadow: initial;
}
.sc-btn[disabled="true"] > .sc-span { /* comes after */
    opacity: 0.3; // for buttons with image
}

input[type="range"]:disabled {
    opacity: 0.4;
}

.sc-keyed {
  background-image: linear-gradient(to bottom, white, #96fc96);
}
.sc-keyed:hover {
  background-image: linear-gradient(to bottom, white, #d2ffd2);
}


input:disabled + .sc-btn,
input:disabled + .sc-btn:hover,
input:disabled + .sc-btn:active, 
.sc-btn[disabled="true"] {
  color:#ddd;
  background-image: linear-gradient(to bottom, white, #ebebeb);
  box-shadow: initial;
}
.sc-btn:disabled + span {
  opacity:0.6
}


#addingCube {
  background-image: linear-gradient(to bottom, white, #DADAFD);
}
#addingCube:active, #addingCubeCheck:checked + #addingCube{
    color: #fff;
    background-image: linear-gradient(to bottom, #61adf4, #1067c1); 
}
#removingCube {
  background-image: linear-gradient(to bottom, white, #FDDADA);
}
#removingCube {
    left: 115px;
}
#removingCube:active, #removingCubeCheck:checked + #removingCube{
    color: #fff;
    background-image: linear-gradient(to bottom, #f57979, #e32323); 
}

#aboutBtn {
   right: 8px;
   width: 40px;
   bottom: 8px;
   height: 30px;
   line-height: 30px;
}
#urlBtn {
   right: 50px;
   bottom: 8px;
   width: 40px;
   height: 30px;
}
#exportBtn {
   right: 92px;
   bottom: 8px;
   width: 40px;
   height: 30px;
   z-index: 0; /* below editor back */
}

#prevBtn {
   width: 50px;
   height: 50px;
   bottom: 50px;
   left: 10px;
}
#prevBtnIn {
    background: url(back_arrow.png) center no-repeat; 
    display: inline-block; 
    width:50px;
    height:50px; 
}
#nextBtn {
   width: 120px;
   height: 50px;
   bottom: 50px;
   left: 65px;
}
#nextBtnIn {
   /* background: url(gears/gear_anim.gif) left no-repeat; */
    background: url(gears/g1_lightg.png) left no-repeat; 
    display: inline-block; 
    width: 56px;
    height: 50px;
    margin: 0 0 0 5px;
}
#nextBtnIn2 {
    background: url(forward_arrow.png) left no-repeat;
    display: inline-block; 
    height: 50px;
    width: 31px;
}

#slvNum {
    position: absolute;
    bottom: 24px;
    width: 100px;
    font-family: monospace;
    left: 24px;
    font-size: 16pt;
    color: #666;
}

#picNum {
    position: absolute;
    top: 60px;
    width: 180px;
    font-family: monospace;
    left: 24px;
    font-size: 18pt;
    color: #414141;
    text-align: center;
}

.popupBack {
    display: none;
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(20,20,20, 0.82);
    top: 0;
    left: 0;
    z-index: 1; /* above the export button which is an appended child */
}
.popupWin {
    position: absolute;
    width: 600px;
    height: 460px;
    top: 25%;
    left: 0;
    right: 0;
    margin-left: auto;
    margin-right: auto;
    background: #FFF;
    border-radius: 15px;
    padding: 20px;
}

h1, h2, h3 {
    margin: 0;
    font-family: Tahoma;
}
h3 {
    font-size: 12px;
    font-family: monospace;
    margin: 30px 0 0 0;
}
h2 {
    font-size: 20px;
}
h1 {
    font-size: 30px;
    margin: 0 0 0 30px;
}
.transBack {
    visibility: hidden;
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0, 0);
    top: 0;
    left: 0;
    z-index: 2;
}
#urlPopup {
    position: absolute;
    bottom: 50px;
    right: 56px;
    width: 300px;
    height: 36px;
    background: #ededed;
    border-radius: 6px;
    border: 1px outset #A9A7A7;
}
#urlEdit {
    height: 20px;
    margin: 5px;
    width: 286px;
}

#exportPopup {
    position: absolute;
    bottom: 50px;
    right: 96px;
    width: 220px;
    height: 70px;
    background: #ededed;
    border-radius: 6px;
    border: 2px outset #A9A7A7;
    padding: 4px;
    font-size: 12pt;
}

#addFamBtn{
    width: 34px;
    height: 34px;
    margin: 0 7px 7px 7px;
}
#addFamBtnIn {
    background: url(plus.png) center no-repeat; 
    display: inline-block; 
    width: 34px; 
    height: 33px;
}
.addCubeBtn {
    width: 34px;
    height: 25px;
    left: 150px;
    margin: 0;
}
.addCubeBtnIn {
    background: url(plus.png) center no-repeat; 
    display: inline-block;
    width: 34px;
    height: 24px;
    vertical-align: top;
}
.linklike {
    cursor: pointer;
    color: blue;
    text-decoration: underline;
}

/* ------------ editor stuff */

#picEditWin {
    height: 550px;
}


#editDoneBtn {
   right: 8px;
   width: 60px;
   bottom: 8px;
}

.color {
   padding: .5em;
   margin-right: .4em;
   border: 1px solid #aaa;
   border-radius: 3px;
   width: 140px;
   font-family: monospace;
   font-size: 110%;
}

#editUploadBtn {
   width: 40px;
   margin: 0 0 0 10px;
}
#editUploadBtnIn {
   background: url(upload.png) center no-repeat; 
   display: inline-block; 
   width: 40px; 
   height: 36px;

}
#editActionPieces {
    top: 20px;
    right: 40px
}


input:checked + .sc-btn
{
  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
  color: #fff;
}

#editActionMove {
    top: 70px;
    right: 40px
}

#editRotL {
    top: 120px;
    right: 45px;
    width: 40px;
}
#editRotR {
    top: 120px;
    right: 95px;
    width: 40px;
}
#editRotLIn {
    background: url(rot_left.png) center no-repeat;
    display: inline-block;
    width: 40px;
    height: 38px;
}
#editRotRIn {
    background: url(rot_right.png) center no-repeat;
    display: inline-block;
    width: 40px;
    height: 38px;    
}


#editBackColor {
    position: absolute;
    width: 60px;
    right: 65px;
    top: 240px;
}
#editFrontColor {
    position: absolute;
    width: 60px;
    right: 65px;
    top: 285px;
}
#editBlackSel {
    position: absolute;
    width:90px;
    right: 57px;
    top: 330px;
    height: 26px;
    border-radius: 4px;
}

#editZoomSlider {
    position: absolute;
    height: 200px;
    width: 40px;
    right: 8px;
    top: 30px;
    -webkit-appearance: slider-vertical;
    writing-mode: bt-lr
}
#editZoomText {
    position: absolute;
    top: 240px;
    width: 40px;
    right: 8px;
    text-align: center;
    height: 20px;
}

.editFillRadio, .editFillLabel {
    font-family: "Helvetica Neue", "Helvetica", sans-serif;
    font-size:110%;
    margin: 6px;
}
#editFillColor {

}
#editFillTexture {

}
.fillRadio {
    height: 40px;
    width: 150px;
    position: static;
    margin: 1px;
    text-align: left;
    text-indent: 10px;
}


#editFileButton {
    position: static;
    height: 40px;
    margin: 1px 1px 1px 10px;
    width: 70px;
}

.editText:disabled {
    color: #b0b0b0;
    background-color: #ececec;
    border: #b0b0b0 solid 1px;
}
.editText {
    border: #7c7c7c solid 1px;
    border-radius: 4px;
}

#editFileName {
    height: 24px;
    margin: 7px 1px 7px 10px;
    width: 250px;
    text-indent: 5px;
    vertical-align: top; 
}

#editUploadProgress {
    position: absolute;
    top: 470px;
    left: 185px;
    width: 338px;
    height: 25px;
    visibility: hidden;
}
#editErrMsg {
    position: absolute;
    top: 460px;
    left: 280px;
    color: red;
    font-family: tahoma;
    font-weight: bold;
}

/*--------------- ipic (single piece picker)*/

#ipicWin {
    position: absolute;
    width: 235px;
    height: 175px; 
    border-radius: 7px;
    right: 220px;
    top: 100px;   
    background: #fff;
    visibility: hidden;
    z-index: 1;
}
#ipicCanvas {
    position: absolute;
    border-radius: 7px;
}
#inputsContainer {
    position: relative;
}
.ipic_check {
    position: absolute;
    width: 17px;
    height: 17px;
    z-index: 2;
}
#ipic1Lbl { left: 50px;  top: 50px; }
#ipic2Lbl { left: 50px;  top: 110px;}
#ipic3Lbl { left: 110px; top: 50px; }
#ipic4Lbl { left: 110px; top: 110px;}
#ipic5Lbl { left: 170px; top: 50px; }
#ipic6Lbl { left: 170px; top: 110px;}

#keyBack {
    top: 10px;
    background: #666;
    width: 200px; 
    height: 40px;    
    border-radius: 6px;
    display: inline-block;
}
#inKey {
    display: block;
    margin: 8px auto 0 auto;
    height: 17px;
    width: 180px;
    font-family: monospace;
}



</style>
</head>
<body id="body" onload="start()" onresize="doResize()" >
  <div id="side_ctrl">
    <input id="addingCubeCheck" class="hidden" onclick="triggerAdd()" type="checkbox">
    <label id="addingCube" class="sc-btn" for="addingCubeCheck" >Add</label>
    <input id="removingCubeCheck" class="hidden" onclick="triggerRemove()" type="checkbox"/>
    <label id="removingCube" class="sc-btn" for="removingCubeCheck">Remove</label>
    <div id="picNum">10/20</div>
    <label id="aboutBtn" class="sc-btn" onclick="triggerAbout(true)">?</label>
    <label id="urlBtn" class="sc-btn" onclick="triggerUrl()">
        <span style="background: url(url-icon_s3.png) center no-repeat; display: inline-block; width: 30px; height: 30px;"></span>
    </label>
    
    <label id="prevBtn" class="sc-btn" onclick="triggerPrev()">
        <span id="prevBtnIn" class="sc-span"></span>
    </label>
    <label id="nextBtn" class="sc-btn" onclick="triggerNext()">
        <span id="nextBtnIn" class="sc-span"></span>
        <span id="nextBtnIn2" class="sc-span"></span>
    </label>
    <div id="slvNum"></div>

    <div id="side_rel" class="in_rel">
      <div id="fams_cont"></div>
    </div>

    <div id="editBack" class="popupBack"><div id="picEditWin" class="popupWin">
        <canvas id="editCanvas" width="590", height="450"></canvas>
        <label id="editDoneBtn" class="sc-btn" onclick="triggerEditDone()"/>Done</label>
        <input id="editBackColor" class="color" oninput="changedColorText(0, true)"/>
        <input id="editFrontColor" class="color" oninput="changedColorText(1, true)"/>
        <select id="editBlackSel" oninput="triggerBlackSel()">
            <option value="auto">Auto Lines</option>
            <option value="normal">Normal Lines</option>
            <option value="white">White Lines</option>
        </select>
        
        <input id="editActionPiecesCheck" class="hidden" onclick="triggerAction(1)" type="checkbox">
        <label id="editActionPieces" class="sc-btn" for="editActionPiecesCheck"/>Edit Pieces</label>
        <input id="editActionMoveCheck" class="hidden" onclick="triggerAction(2)" type="checkbox">
        <label id="editActionMove" class="sc-btn" for="editActionMoveCheck"/>Move Image</label>
        <input id="editZoomSlider" type="range" orient="vertical" min="20" max="200" step="1" oninput="changeImgZoom(1,editZoomSlider.value)"/>
        <input id="editZoomText" type="text" class="editText" oninput="changeImgZoom(2,parseFloat(editZoomText.value))"/>
        <label id="editRotL" class="sc-btn" onclick="triggerRotate(-1)">
            <span id="editRotLIn" class="sc-span"></span></label>
        <label id="editRotR" class="sc-btn" onclick="triggerRotate(1)">
            <span id="editRotRIn" class="sc-span"></span></label>
        <br>
        <input id="editFillColorRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(0)">
        <label id="editFillColor" class ="sc-btn fillRadio" for="editFillColorRadio">Uniform Color</label><br>
        <input id="editFillTextureRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(0x14)">
        <label id="editFillTexture" class ="sc-btn fillRadio" for="editFillTextureRadio">From Image</label>
          <input id="editFileInput" type="file" class="hidden" onchange="return triggerFileChanged()">
          <label id="editFileButton" class="sc-btn" for="editFileInput">File...</label>
          <input id="editFileName" class="editText" type="text" value="" oninput="triggerEditChanged()">
          <label id="editUploadBtn" class="sc-btn" onclick="triggerEditUpload()"/>
            <span id="editUploadBtnIn" title="Upload Now" class="sc-span"></span></label>
          <br>
          <progress id="editUploadProgress" max="100" value="0"></progress>
          <span id="editErrMsg"></span>
        <input id="editFillMarbleRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(4)">
        <label id="editFillMarble" class ="sc-btn fillRadio" for="editFillMarbleRadio">Marble Mix</label><br>
        <input id="editFillMixRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(2)">
        <label id="editFillMix" class ="sc-btn fillRadio" for="editFillMixRadio">Color Mix</label><br>
        

        <img id="edit_marble" src="bw_marble3_sm.jpg" style="display:none;"/>
        <img id="edit_profi" src="bw_profi2_sm.jpg" style="display:none;"/>

        <canvas id="canvas_scratch" style="display:none;"></canvas>

    </div></div>
  </div>

    <div id="ipicWin">
        <div id="inputsContainer">
        <input id="ipic1" type="checkbox" class="mycheck hidden" onchange="on_pic_check(1,this.checked)">
        <label id="ipic1Lbl" for="ipic1" class="mycheck_label ipic_check" ></label>
        <input id="ipic2" type="checkbox" class="mycheck hidden" onchange="on_pic_check(2,this.checked)">
        <label id="ipic2Lbl" for="ipic2" class="mycheck_label ipic_check" ></label>
        <input id="ipic3" type="checkbox" class="mycheck hidden" onchange="on_pic_check(3,this.checked)">
        <label id="ipic3Lbl" for="ipic3" class="mycheck_label ipic_check" ></label>
        <input id="ipic4" type="checkbox" class="mycheck hidden" onchange="on_pic_check(4,this.checked)">
        <label id="ipic4Lbl" for="ipic4" class="mycheck_label ipic_check" ></label>
        <input id="ipic5" type="checkbox" class="mycheck hidden" onchange="on_pic_check(5,this.checked)">
        <label id="ipic5Lbl" for="ipic5" class="mycheck_label ipic_check" ></label>
        <input id="ipic6" type="checkbox" class="mycheck hidden" onchange="on_pic_check(6,this.checked)">
        <label id="ipic6Lbl" for="ipic6" class="mycheck_label ipic_check" ></label>
        
        </div>
        <canvas id="ipicCanvas"></canvas>
    </div>
    
    <div id="urlBack" class="transBack" onclick="triggerUrl()">
        <div id="urlPopup"><input id="urlEdit" type="text" onchange="urlEditChanged()"/></div>
    </div>    
    <div id="exportBack" class="transBack" onclick="triggerExport()">
        <div id="exportPopup">Exported Model:<br><a id="linkObj" href="">file.obj</a><br><a id="linkMtl" href="">file.mtl</a></div>
    </div>
    
    <div id="canvasCont">
        <canvas id="mycanvas" width="800" height="700"></canvas>
        <div id="errBack"><div id="errNotify">
            ERROR
        </div></div>
    </div>
    
    <div id="aboutBack" class="popupBack"><div id="aboutWin" class="popupWin">
    <h1>Happy Cube Solver</h1><br>
    <h2>Designed and implemented by Shy Shalom (1995 - 2016)<br>
    <a href="mailto:shooshx@gmail.com" target="_blank">shooshx@gmail.com</a><br></h2>
    <h3>Using this program automatically implies that you respect the copyrights on the Happy Cube&copy;&reg; Puzzles.<br>
This program is indented to support you while playing live with the Happy Cube&copy;&reg; Puzzles. These puzzles are worldwide manufacturered by HAPPY bvba, Belgium, on licensed and thus restricted base (<a href="http://www.happy.be" target="_blank" id="linka">www.happy.be</a>). The Happy Cube puzzles are the result of a real invention in 1986 by Dirk Laureyssens. This means that using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law, since the Happy Cube Puzzles are worldwide protected by many US copyrights since 1987.<br>
Please note that using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law, since the Happy Cube&copy;&reg; Puzzles are worldwide protected by US copyrights since 1987.<br>
Puzzles copyright (C) Dirk Laureyssens 1986-2016. All rights reserved. The Happy Cube puzzles are protected with several US copyrights since 1987 (TXU 271722, TX2332525, TX2359816 and many others). They are exclusively manufactured by Happy bvba, B-2980 Zoersel, Belgium, and distributed worldwide by partners. Using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law. 
Happy Cube, Little Genius, Profi Cube and Marble Cube are registered trademarks of Happy bvba, Zoersel, Belgium. 
If you have any questions concerning the usage of HAPPY materials, please send your detailed request in writing to <a href="mailto:info@happy.be" target="_blank">info@happy.be</a>. See <a href="http://www.happy.be" target="_blank">http://www.happy.be</a> for more information</h3>
    </div></div>
    
    <img id="noisetex" src='cubeTex.png' style="display:none;"/>
    <img src="arrow_up.png" style="display:none;"/>
    <img src="arrow_down.png" style="display:none;"/>
    <img id="newgenious" src="../new_genious128.png" style="display:none;"/>
    <img id="genious" src="../littlegenious128_2.png" style="display:none;"/>
    <img id="dummy_check1" src="check_int.png" style="display:none;"/> <!-- avoid flicker -->
    <img id="blank_tex" src="blank_tex.png" style="display:none;"/>
    <img id="dummy_anim" src="gears/gear_anim.gif" style="display:none;"/>
    <img id="dummy_pause" src="pause.png" style="display:none;"/>
    <div id="stat"></div>
    
</body>
</html>
