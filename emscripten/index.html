<!doctype html>
<html><head>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2231125-5', 'auto');
  ga('send', 'pageview');
</script>

<link rel="icon" href="favicon.ico" type="image/x-icon"/>
<script id="stdpcs" src="stdpcs.js"></script>  
<script id="unimesh2" src="unified_mesh.js"></script>  
<script id="one_cube" src="one_piece_cube.js"></script>    
<!--<script id="one_cube" src="one_marble_cube.js"></script>    -->

<script type="text/javascript" src="colorPick/color.all.min.js"></script> <!-- https://github.com/PitPik/colorPicker  -->
<script type="text/javascript" src="colorPick/jsColor.js"></script>

<script type="text/javascript">

// unified_mesh.js
// j_unified_meshes_all.txt
    
var gl = null
var prog = null
var model = { vtxBuf: null }

var loadSolution, resizeGl, mouseUp, mouseDown, mouseMove, mouseDblClick, mouseWheel, cpp_draw, cpp_slvrun, getTms
var setGrpCount, setEditAction, runningRestart, serializeCurrent, deserializeAndLoad, readCube, newRestart, conf
var stackState, textureParamCube, getCubeTextureHandle, readCubeTexCoord, loadSlvSimple, freeMeshAllocator
var ctrlPressed = false
var editCtx = null
var unimesh_keys = Object.keys(unimesh) // unimesh included above
var readFrameBuf = null, readFrameView = null // buffer for selection readPixels. don't want it managed by emscripten

var ACT_NONE = 0, ACT_ADD = 1, ACT_REMOVE = 2

var colorPickCfg = null 
    
function start() 
{
    colorPickCfg = {
        customBG: '#222',
        readOnly: true,
        // patch: false,
        init: function(elm, colors) { // colors is a different instance (not connected to colorPicker)
          elm.style.backgroundColor = elm.value;
          // used to be rgbaMixCustom the color mixed with the customBG color (not relevant for me since alpha is 1.0 always)
          elm.style.color = colors.rgbaMixWhite.luminance > 0.22 ? '#222' : '#ddd';
        },
        initStyle: 'display: hidden',
        mode: 'hsv-h',
        noAlpha: true,
        size: 1,
        appendTo: editBack,
        displayCallback:changeColor,
        multipleInstances:true
    }
    jsColorPicker('input.color', colorPickCfg);
    
  /*  picsAddFamily("Happy Cube", "hc")
    picsAddCube("Blue", "hc_blue")
    picsAddCube("Red", "hc_red")
    picsAddCube("Purple", "hc_purple")
    picsAddFamily("Profi Cube", "pc")
    picsAddCube("AAAA", "pc_aaa")
    picsAddCube("BBBB", "pc_bbbb")
    //return
*/

    loadSolution = Module.cwrap('loadSolution', null, ['string'])
    resizeGl = Module.cwrap('resizeGl', null, ['number', 'number'])
    mouseDown = Module.cwrap('mouseDown', null, ['number', 'number', 'number'])
    mouseUp = Module.cwrap('mouseUp', null, ['number'])
    mouseMove = Module.cwrap('mouseMove', null, ['number', 'number', 'number', 'number'])
    mouseDblClick = Module.cwrap('mouseDblClick', null, ['number', 'number', 'number'])
    mouseWheel = Module.cwrap('mouseWheel', null, ['number'])
    cpp_draw = Module.cwrap('cpp_draw', 'boolean', ['number'])
    cpp_slvrun = Module.cwrap('cpp_slvrun', 'boolean', [])
    getTms = Module.cwrap('getTms', 'number', [])
    solveGo = Module.cwrap('solveGo', null, [])
    setGrpCount = Module.cwrap('setGrpCount', null, ['number', 'number'])
    setEditAction = Module.cwrap('setEditAction', null, ['number'])
    runningRestart  = Module.cwrap('runningRestart', null, [])
    serializeCurrent  = Module.cwrap('serializeCurrent', 'number', [])
    deserializeAndLoad = Module.cwrap('deserializeAndLoad', null, ['number'])
    readCube = Module.cwrap('readCube', null, ['number'])
    newRestart  = Module.cwrap('newRestart', null, [])
    conf = Module.cwrap('conf', null, ['number'])
    stackState = Module.cwrap('stackState', null, ['number'])
    textureParamCube = Module.cwrap('textureParamCube', null, ['number','number','number','number','number','number','number','number','number']) // grpi,drawtype,r,g,b,r,g,b,isBlack
    getCubeTextureHandle = Module.cwrap('getCubeTextureHandle', 'number', ['number', 'number', 'number'])
    readCubeTexCoord = Module.cwrap('readCubeTexCoord', null, ['number'])
    loadSlvSimple = Module.cwrap('loadSlvSimple', null, ['string'])
    freeMeshAllocator = Module.cwrap('freeMeshAllocator', null, [])
    
    Module.ccall('cpp_start', null);
    conf(true)
    Module.ccall('initCubeEngine', 'boolean', ['string', 'number'], [stdpcs_text, 0])
    
    loadSolution(one_piece_cube_text)
    //loadSolution(one_marble_cube_text)

    if (window.location.search.length > 0) {
        loadUrl(window.location.toString())
    }

    //solveGo()
    
    doResize();
    //resize(mycanvas.width, mycanvas.height)
    
    mycanvas.onmousedown = handleMouseDown
    document.onmouseup = handleMouseUp
    mycanvas.onmousemove = handleMouseMove
    mycanvas.ondblclick = handleMouseDblClick
    mycanvas.onwheel = mycanvas.onmousewheel = handleMouseWheel // second one is for internet explorer
    editCanvas.onclick = handleEditCanvasClick
    editCanvas.onmousemove = handleEditCanvasMove
    editCanvas.onmousedown = handleEditCanvasDown
    
    document.onkeydown = handleKeyDown
    document.onkeyup = handleKey  

   
    // start drawing
    requestAnimationFrame(animProgress)
    setInterval(sampleTms, 1000)
    
    addingCubeCheck.checked = true
    setCheck(addingCube, true)
    removingCubeCheck.checked = false
    setCheck(removingCube, false)
    setEditAction(ACT_ADD) 
    
    // editor init
    editCtx = editCanvas.getContext("2d")

    picsAddFamily("Test Fam", "Test Fam", true)
    picsAddCube("Test Cube", "Test Cube", -1, true)
    
    
}

function handleMouseDown(event) {
    mouseDown( (event.button == 2)?1:0, event.clientX, event.clientY)
    //return false
}
function handleMouseUp(event) {
    mouseUp( (event.button == 2)?1:0)
    // returning false here breaks the spinbox
    //return false
}
var lastX = null, lastY = null
function handleMouseMove(event) {
    if (event.clientX == lastX && event.clientY == lastY)
        return; // for some reason this event arrives in clicks as well
    lastX = event.clientX
    lastY = event.clientY
    var but = event.buttons
    if (but === undefined)
        but = event.which // for safari
    mouseMove(but, ctrlPressed?1:0, event.clientX, event.clientY)
    return false
}
function handleMouseDblClick(event) {
    mouseDblClick(ctrlPressed?1:0, event.clientX, event.clientY);
    return false
}
function handleMouseWheel(event) {
    var d = event.wheelDelta
    mouseWheel( (d > 0) ? 16 : -16)
    return false
}

function handleKeyDown(event) {
    if (event.keyCode == '65' && event.ctrlKey) {
        var s = window.prompt("slv data")
        loadSlvSimple(s)
        return
    }
    handleKey(event)
}

function handleKey(event) {
    if (event.ctrlKey == ctrlPressed)
        return;
    ctrlPressed = event.ctrlKey;
    mouseMove(0, ctrlPressed?1:0, lastX, lastY)
    return false
}

var lastFamAdded = ''
var pics_families = {} // make family id to { cubes: list of { cid: cube-id, grpi: group-index } }
var pics_cubes = {} // make cube id to { famid }
var max_grpi = 0; // the largest cube number we've seen. used for adding more cubes in the ui

function picsAddFamily(famName, id, editable) {
    id = id.replace(/[-\. ]/g, '_')
    var editTag = ''
    if (editable) {
        editTag = '<label class="addCubeBtn sc-btn"  onclick="triggerAddCube(\'ID\')"/></label>'
    }
    var picsCtrl = '<div id="ID_frame" class="toppic"><div class="famtitle">\
    <input class="fam_check_box hidden mycheck" id="ID_fcheck" type="checkbox" onchange="on_fam_check(\'ID\', ID_fcheck.checked, true);setCheck(ID_fcheck_label, ID_fcheck.checked)" />\
    <label class="fam_check mycheck_label" id="ID_fcheck_label" for="ID_fcheck" ></label>ADDEDIT\
    <div class="fam_label" onclick="pic_rolldown(\'ID\')">LABEL</div>\
    <img class="toppic_icon" id="ID_img" src="arrow_up.png" onclick="pic_rolldown(\'ID\')"></div> \
    <div id="ID_famframe" class="inframe"></div> \
    </div>'.replace(/ADDEDIT/g, editTag).replace(/ID/g, id).replace(/LABEL/g, famName)

    var dummy = document.createElement("DIV")
    dummy.innerHTML = picsCtrl;
    fams_cont.appendChild(dummy.firstChild) // this way I avoid recreating the whole panel each time and making the selection invalid (as opposed to .innerHTML +=)
    
    lastFamAdded = id
    pics_families[id] = { cubes: []}
    
}
function picsAddCube(cubeName, id, grpi, editable) {
    if (grpi == -1)
        grpi = max_grpi + 1
    id = id.replace(/[-\. ]/g, '_')
    var editStart = '', editEnd = ''
    if (editable) {
        editStart = "<span class='linklike' onclick=triggerCubeEdit(true,INDEX)>"
        editEnd= "</span>"
    }
    var txt = '<div id="ID_inframe" class="piccube">\
    <input class="cube_check_box hidden mycheck" id="ID_ccheck" type="checkbox" onchange="on_cube_check(\'ID\', ID_ccheck.checked, INDEX);setCheck(ID_ccheck_label, ID_ccheck.checked)"/>\
    <label class="cube_check mycheck_label" id="ID_ccheck_label" for="ID_ccheck" ></label>EDITSTARTLABELEDITEND\
    <input class="cube_count" id="ID_ccount" type="number" min="0" onchange="on_cube_count(\'ID\', INDEX)">\
    </div>'.replace(/EDITSTART/g, editStart).replace(/EDITEND/g, editEnd).replace(/ID/g, id).replace(/LABEL/g, cubeName).replace(/INDEX/g, grpi)
    
    document.getElementById(lastFamAdded + "_famframe").innerHTML += txt
    pics_families[lastFamAdded].cubes.push( { cid: id, grpi: grpi})
    pics_cubes[id] = { famid: lastFamAdded }
    
    if (grpi > max_grpi)
        max_grpi = grpi
}

// update the cube count after a check is changed. v is boolean for the value of the check
function dispCCount(id, v, gind) {
    var ccount = document.getElementById(id + "_ccount")
    ccount.style.display = (v ? "inline":"none")
    if (v && ccount.value <= 0)
        ccount.value = 1
    
    if (v)
        setGrpCount(gind, ccount.value)
    else
        setGrpCount(gind, 0)
}

function setCheck(idlabel, v) {
    idlabel.classList.remove('mycheck_inter')
    if (v === true)
        idlabel.classList.add('mycheck_checked')
    else if (v === false)
        idlabel.classList.remove('mycheck_checked')
    
}
function setIntermediate(idlabel, v) {
    if (v === true)
        idlabel.classList.add('mycheck_inter')
    else if (v === false)
        idlabel.classList.remove('mycheck_inter')
}


function on_fam_check(id, v, doSolve) {
    var fcubes = pics_families[id].cubes;
    for(var i in fcubes) {
        var c = fcubes[i]
        document.getElementById(c.cid + "_ccheck").checked = v
        setCheck(document.getElementById(c.cid + "_ccheck_label"), v)
        dispCCount(c.cid, v, c.grpi)
    }
    if (doSolve) // on inialization select, don't want to do this
        runningRestart()
}

// from C++ on initialization. just need to take care of the checkboxes and count display. the counts are already there
function setFamCheck(id, v) {
    document.getElementById(id + "_fcheck").checked = v
    setCheck(document.getElementById(id + "_fcheck_label"), v)
    on_fam_check(id, v, false)
}

function picFamCheck(id) {
    var famid = pics_cubes[id].famid
    var fcubes = pics_families[famid].cubes;
    var allTrue = true, allFalse = true
    for(var i in fcubes) {
        var cid = fcubes[i].cid
        var iv = document.getElementById(cid + "_ccheck").checked

        allTrue = allTrue && iv
        allFalse = allFalse && !iv
    }
    var famCheck = document.getElementById(famid + "_fcheck")
    var famLabel = document.getElementById(famid + "_fcheck_label")
    famCheck.indeterminate = false
    if (allTrue) {
        famCheck.checked = true
        setIntermediate(famLabel, false)
        setCheck(famLabel, true)
    }
    else if (allFalse) {
        famCheck.checked = false
        setIntermediate(famLabel, false)
        setCheck(famLabel, false)
    }
    else {
        famCheck.indeterminate = true   
        setCheck(famLabel, false)
        setIntermediate(famLabel, true)
    }
}

function on_cube_check(id, v, gind) {
    dispCCount(id, v, gind)
    picFamCheck(id)
    runningRestart()
}

function on_cube_count(id, gind) {
    var ccount = document.getElementById(id + "_ccount")
    var ccheck = document.getElementById(id + "_ccheck")
    var clabel = document.getElementById(id + "_ccheck_label")
    var prevCh = ccheck.checked, newCh = (ccount.value > 0)
    //console.log("COUNT " + prevCh + " " + newCh)
    if (prevCh != newCh) {
        ccheck.checked = newCh
        setCheck(clabel, newCh)
        picFamCheck(id)
    }
    setGrpCount(gind, ccount.value)
    runningRestart()
}

// obj is the int handle of the opengl object
function registerTexBind(imgname, obj) {
    //console.log("reg-tex " + imgname + " " + obj)

    var img = document.getElementById(imgname)
    _glBindTexture(GLctx.TEXTURE_2D, obj)
    GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, img)
}

function requestAnim() {
    requestAnimationFrame(animProgress)
}

function animProgress() {
    var again = cpp_draw(0.2);
    if (again)
        requestAnimationFrame(animProgress)
    
}

var enterSlv = false

function requestSlvRun() {
    setTimeout(slvRun, 0)
    enterSlv = true
}



function slvRun() {
    if (!enterSlv)
        return
    setTimeout(slvRun, 0)  // pre-schedule the next time to avoid delay
    enterSlv = cpp_slvrun()
    //if (again)
    //    setTimeout(slvRun, 0)
    
}

var lastTms = 0
function sampleTms() {
    var tms = getTms()
    var delta = tms - lastTms
    if (delta != 0)
        stat.innerHTML = "" + delta
    lastTms = tms
}



function pic_rolldown(id) {
    var outframe = document.getElementById(id + '_frame')
    var elem = document.getElementById(id + '_famframe')
    var elemImg = document.getElementById(id + '_img')
    
    // roll up anything else that is rolled down
    for(var fid in pics_families) {
        if (fid == id)
            continue
        if (document.getElementById(fid + '_famframe').isOpen) {
            pic_rolldown(fid)
        }
    }
    
    if (elem.isOpen) {
        elem.isOpen = false
        //  elem.style.display = 'none'
        outframe.style.height = "26px";
        elem.style.visibility = 'hidden'
        elem.style.opacity = 0.0

        elemImg.classList.remove('arrowAnimUp')
  
        var newone = elemImg.cloneNode(true); // restart the animation
        elemImg.parentNode.replaceChild(newone, elemImg);
        
        newone.classList.add('arrowAnimDown')
        newone.classList.remove('arrowUpsideDown')
    }
    else {
        elem.isOpen = true
        //  elem.style.display = 'block'
        outframe.style.height = "283px";
        elem.style.visibility = 'visible'
        elem.style.opacity = 1.0
        
        elemImg.classList.remove('arrowAnimDown')

        var newone = elemImg.cloneNode(true);
        elemImg.parentNode.replaceChild(newone, elemImg);

        newone.classList.add('arrowAnimUp')
        newone.classList.add('arrowUpsideDown')
    }
}


function doResize() {
    if (side_ctrl.editMode)
        side_ctrl.style.width = Math.max(window.innerWidth*0.5, 650) + "px"
    mycanvas.width = window.innerWidth - side_ctrl.clientWidth - 16
    mycanvas.height = window.innerHeight - 16
    side_rel.style.height = "" + (window.innerHeight - 220) + "px"
    picEditWin.style.top = (side_ctrl.clientHeight - picEditWin.clientHeight) * 0.5 + "px"
    
    resizeGl(mycanvas.width, mycanvas.height)
    requestAnim()
}

function triggerAdd() {
    if (addingCubeCheck.checked) {
        removingCubeCheck.checked = false
        setEditAction(ACT_ADD) 
    }
    else {
        setEditAction(ACT_NONE)
    }
}
function triggerRemove() {
    if (removingCubeCheck.checked) {
        addingCubeCheck.checked = false
        setEditAction(ACT_REMOVE)
    }
    else {
        setEditAction(ACT_NONE)
    }

}

function triggerAbout(v) {
    aboutBtn.checked = v
    if (v) {
        aboutBack.style.display = "inline"
    }
    else {
        aboutBack.style.display = "none"
    }
    
    aboutWin.onclick = function(e) {
        e.stopPropagation()
    }
}


var scratchArr = []

function bufferToBase64(buf) {
    var binstr = Array.prototype.map.call(buf, function (ch) {
        return String.fromCharCode(ch);
    }).join('');
    return btoa(binstr);
}

function base64ToBuffer(base64) {
    try {
        var binstr = atob(base64);
        var buf = new Uint8Array(binstr.length);
        Array.prototype.forEach.call(binstr, function (ch, i) {
          buf[i] = ch.charCodeAt(0);
        });
        return buf;
    } catch(err) {
        return "";
    }
}

function triggerUrl(v) {
    if (urlPopup.style.visibility == "visible") {
        urlPopup.style.visibility = "hidden"
        return
    }
    scratchArr = []
    serializeCurrent()
    var b = bufferToBase64(scratchArr)
    console.log(b)
    urlPopup.style.visibility = "visible"
    var url = window.location.toString()
    var qmark = url.indexOf('?')
    if (qmark > 0)
        url = url.substr(0, qmark)
    urlEdit.value = url + '?l=' + b
    urlEdit.select()
}

//loadUrl("AQoAAAgAQAAAAARAAQAQAAEAEAQAAQAgCARBHXRogCOG8YptBGEKWzg=")
function loadUrl(b) {
    var srchAt = b.indexOf('?l=')
    if (srchAt != -1)
        b = b.substr(srchAt + 3)
    if (b.length == 0)
        return;
    scratchArr = base64ToBuffer(b)
    deserializeAndLoad(scratchArr.length)
}

function urlEditChanged() {
    loadUrl(urlEdit.value)
    urlPopup.style.visibility = "hidden"
}

function triggerAddFam() {
    var famName = window.prompt("Family Name?","");
    picsAddFamily(famName, famName, true)
}

function triggerAddCube(intoFam) {
    var cubeName = window.prompt("Cube Name?","");
    picsAddCube(cubeName, cubeName, -1, true)
}

var cube = [
   // 0,1,2,3,4,5,6,7,8,9,1011121314
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 0
    [ 0,1,1,1,1,1,0,0,0,0,0,0,0,0,0 ], // 1
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 2
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 3
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 4
    [ 0,1,1,1,1,1,4,4,4,6,6,6,6,6,0 ], // 5
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 6
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 7
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 8
    [ 0,0,0,0,0,0,0,0,0,6,6,6,6,6,0 ], // 9
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 10
]
var cubeX = [
   // 0,1,2,3,4,5,6,7,8,9,1011121314
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 0
    [ 0,0,1,0,1,0,3,0,3,0,5,0,5,0,0 ], // 1
    [ 0,1,1,1,1,1,3,3,3,3,5,5,5,5,0 ], // 2
    [ 0,0,1,1,1,3,3,3,3,5,5,5,5,0,0 ], // 3
    [ 0,1,1,1,1,1,3,3,3,3,5,5,5,5,0 ], // 4
    [ 0,0,1,2,1,3,3,4,3,5,5,6,5,0,0 ], // 5
    [ 0,2,2,2,2,2,4,4,4,4,6,6,6,6,0 ], // 6
    [ 0,0,2,2,2,4,4,4,4,6,6,6,6,0,0 ], // 7
    [ 0,2,2,2,2,2,4,4,4,4,6,6,6,6,0 ], // 8
    [ 0,0,2,0,2,0,4,0,4,0,6,0,6,0,0 ], // 9
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 10
]
var TSZ = 30
var teeth = [
    { x:1,  y:1, p:[0,1] },   { x:2,  y:1, p:[0,1] }, { x:3,  y:1, p:[0,1] }, { x:4,  y:1, p:[0,1] }, { x:5,  y:1, p:[0,1,3] },
    { x:6,  y:1, p:[0,3] },   { x:7,  y:1, p:[0,3] }, { x:8,  y:1, p:[0,3] }, { x:9,  y:1, p:[0,3,5] },  
    { x:10, y:1, p:[0,5] },   { x:11, y:1, p:[0,5] }, { x:12, y:1, p:[0,5] }, { x:13, y:1, p:[0,5] },    

    { x:1,  y:5, p:[0,1,2] }, { x:2,  y:5, p:[1,2] }, { x:3,  y:5, p:[1,2] }, { x:4,  y:5, p:[1,2] }, { x:5,  y:5, p:[1,2,3,4] },
    { x:6,  y:5, p:[3,4] },   { x:7,  y:5, p:[3,4] }, { x:8,  y:5, p:[3,4] }, { x:9,  y:5, p:[3,4,5,6] },
    { x:10, y:5, p:[5,6] },   { x:11, y:5, p:[5,6] }, { x:12, y:5, p:[5,6] }, { x:13, y:5, p:[5,6,0] },    

    { x:1,  y:9, p:[0,2] },   { x:2,  y:9, p:[0,2] }, { x:3,  y:9, p:[0,2] }, { x:4,  y:9, p:[0,2] }, { x:5,  y:9, p:[0,2,4] }, 
    { x:6,  y:9, p:[0,4] },   { x:7,  y:9, p:[0,4] }, { x:8,  y:9, p:[0,4] }, { x:9,  y:9, p:[0,4,6] }, 
    { x:10, y:9, p:[0,6] },   { x:11, y:9, p:[0,6] }, { x:12, y:9, p:[0,6] }, { x:13, y:9, p:[0,6] },   
    
    { x:1, y:2, p:[0,1] }, { x:1, y:3, p:[0,1] }, { x:1, y:4, p:[0,1] },
    { x:1, y:6, p:[0,2] }, { x:1, y:7, p:[0,2] }, { x:1, y:8, p:[0,2] },    
    
    { x:5, y:2, p:[1,3] }, { x:5, y:3, p:[1,3] }, { x:5, y:4, p:[1,3] },
    { x:5, y:6, p:[2,4] }, { x:5, y:7, p:[2,4] }, { x:5, y:8, p:[2,4] },

    { x:9, y:2, p:[3,5] }, { x:9, y:3, p:[3,5] }, { x:9, y:4, p:[3,5] },
    { x:9, y:6, p:[4,6] }, { x:9, y:7, p:[4,6] }, { x:9, y:8, p:[4,6] },
    
    { x:13, y:2, p:[0,5] }, { x:13, y:3, p:[0,5] }, { x:13, y:4, p:[0,5] },
    { x:13, y:6, p:[0,6] }, { x:13, y:7, p:[0,6] }, { x:13, y:8, p:[0,6] },    
]

var DRAW_COLOR = 0
var DRAW_PROFI = 2
var DRAW_MARBLE = 4
var DRAW_TEX = 0x14

var EDIT_MARGIN = 5

var col = ['white', '#5555ff', 'red', 'yellow', 'orange', 'green', 'purple']
var editImg = null, loadedImg = null
var imgOffset = {x:0, y:0}
var imgZoom = 1.0
var drawType = DRAW_COLOR
var colorBack = new Colors({color:"#ffffff"}).colors
var colorFront = new Colors({color:"#000000"}).colors // main init setting that spreads to everywhere else


function drawLine(x, y, w, h) {
    editCtx.beginPath()
    editCtx.moveTo(x, y)
    editCtx.lineTo(x + w, y + h);
    editCtx.stroke();
}

function paintCube()
{
    editCtx.fillStyle = '#fff'
    editCtx.fillRect(0, 0, editCanvas.width, editCanvas.height)
    
    if (editImg && editImg.loadedOk) 
    {
        editCtx.fillStyle = '#'+colorBack.HEX
        editCtx.fillRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ) // need to show up below transparent pixels
        
        var cwidth = editCanvas.width - 2*EDIT_MARGIN
        var cheight = cwidth * editImg.height / editImg.width  // maintain same aspect ratio as the image
        editCtx.drawImage(editImg, 0,0, editImg.width, editImg.height, 
                                   imgOffset.x + EDIT_MARGIN, imgOffset.y + EDIT_MARGIN, cwidth*imgZoom, cheight*imgZoom)
    }
    else if (current_src) // indicates colored_tex is on
    {
        editCtx.putImageData(colored_tex, EDIT_MARGIN, EDIT_MARGIN)
    }
    else {
        editCtx.fillStyle = '#'+colorBack.HEX
        editCtx.fillRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ)
    }
    
    editCtx.strokeStyle = 'black'
    editCtx.lineWidth = 1
    
    // frame
    editCtx.strokeRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ)

   /* for(var x = 0; x < 15; ++x) {
        for(var y = 0; y < 11; ++y) {
            var v = cube[y][x]
            editCtx.fillStyle = col[v]
            editCtx.fillRect(x * TSZ, y * TSZ, TSZ, TSZ)    
        }
    }*/

    editCtx.strokeStyle = isColorsBlack() ? 'white':'black'
    
    for(var x = 0; x < 15; ++x) {
        for(var y = 0; y < 11; ++y) {
            var v = cube[y][x]
            editCtx.fillStyle = col[v]
            if (y < 10 && x < 14) {
                if (v != cube[y+1][x]) {
                    drawLine(x * TSZ + EDIT_MARGIN, y * TSZ + TSZ + EDIT_MARGIN, TSZ, 0)
                }
                if (v != cube[y][x+1]) {
                    drawLine(x * TSZ + TSZ + EDIT_MARGIN, y * TSZ + EDIT_MARGIN, 0, TSZ)
                }                
            }
        }
    }
}

function loadTexImage(urlOrImg)
{
    var onload = function() {
        loadedImg.loadedOk = true
        var obj = getCubeTextureHandle(editingCubeId, loadedImg.width, loadedImg.height)
        if (obj == 0)
            return
        console.log("setting img to texture " + obj)
        _glBindTexture(GLctx.TEXTURE_2D, obj)
        GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, loadedImg)
        editImg = loadedImg
        sendTexCoord()
        paintCube()
    }
    
    if (typeof(urlOrImg) != "string")  // its an image
    {
        loadedImg = urlOrImg
        onload()
        return
    }
    // its a url
    loadedImg = new Image()
    loadedImg.onload = onload
    loadedImg.crossOrigin = ''
    loadedImg.src = urlOrImg
    
}

var editingCubeId = -1
var src_marble = null, src_profi = null // ImageData of the B&W images
var current_src = null, colored_tex = null //ImageData chosen src from the above and the resulting colored

function makeColoredTex()
{
    if (current_src == null)
        return
    var dst = colored_tex.data
    var src = current_src.data
    var fr = colorFront.rgb.r, fg = colorFront.rgb.g, fb = colorFront.rgb.b
    var br = colorBack.rgb.r, bg = colorBack.rgb.g, bb = colorBack.rgb.b
    for (var i = 0; i < dst.length; i += 4) 
    {
        var g = src[i]
        var rg = 255-g
        dst[i]     = br * g + fr * rg  // red
        dst[i + 1] = bg * g + fg * rg // green
        dst[i + 2] = bb * g + fb * rg // blue
        dst[i + 3] = 255;
    }
}

function triggerCubeEdit(v, cubeId) // cube link pressed or Done pressed
{
    if (v) 
    {
        editBack.style.display = "inline"
        side_ctrl.editMode = true // for resize
        doResize()
        editActionPiecesCheck.checked = true
        editActionMoveCheck.checked = false
        editZoomSlider.value = 100
        editZoomText.value = "100%"
        editFillColorRadio.checked = true

        setEditAction(ACT_NONE) // prevent hovering on the cube from editing

        editingCubeId = cubeId

        stackState(0) // push and clear
        
        readCube(editingCubeId)
        setGrpCount(editingCubeId, 1) // set it to be selected TBD - set back to what it was
        conf(false) // make it not randomized so that the solution would be more or less the same
        
        editCanvas.height = 11*TSZ + 2*EDIT_MARGIN
        editCanvas.width = 15*TSZ + 2*EDIT_MARGIN
        
        editBackColor.value = "#"+colorBack.HEX
        colorPickCfg.init(editBackColor, colorBack);
        editFrontColor.value = "#"+colorFront.HEX
        colorPickCfg.init(editFrontColor, colorFront);
        
        // transfer the marble,profi images to the canvase so they could be accessed when the time comes
        if (!colored_tex) {
            var run_image = function(img, canvas) {
                canvas.width = 15*TSZ
                canvas.height = 11*TSZ
                var ctx = canvas.getContext('2d')
                ctx.drawImage(img, 0,0)
                return ctx.getImageData(0,0, canvas.width,canvas.height)
            }
            src_marble = run_image(edit_marble, canvas_marble)
            src_profi = run_image(edit_profi, canvas_profi)
            colored_tex = editCtx.createImageData(15*TSZ,11*TSZ)
        }
        
        paintCube()   
        newRestart()        
    }
    else 
    {
        readCube(editingCubeId)
        editingCubeId = -1
        
        freeMeshAllocator()
        conf(true)  // revert back to randomized
        stackState(1) // pop last

        editBack.style.display = "none"
        side_ctrl.style.width = "230px"
        side_ctrl.editMode = false
        doResize()
        if (addingCubeCheck.checked)
            setEditAction(ACT_ADD)
        else if (removingCubeCheck.checked)
            setEditAction(ACT_REMOVE)
    }
}

var lastDrag = null
function handleEditCanvasDown(event)
{
    lastDrag = {x:event.clientX, y:event.clientY}
}

function handleEditCanvasMove(event)
{
    if (!editActionMoveCheck.checked)
        return
    if (event.buttons != 1 || lastDrag == null) // left mouse button
        return

    imgOffset.x += event.clientX - lastDrag.x
    imgOffset.y += event.clientY - lastDrag.y
    lastDrag = {x:event.clientX, y:event.clientY}
    
    paintCube()
    sendTexCoord()
}

function handleEditCanvasClick(event)
{
    if (editActionPiecesCheck.checked)
        checkToothClick(event)
}
 
function checkToothClick(event)
{ 
    var rect = editCanvas.getBoundingClientRect()
    var x = Math.trunc((event.clientX - rect.left)/TSZ), y = Math.trunc((event.clientY - rect.top)/TSZ)
    //console.log(x + " " + y)
    
    var hasSameNei = function(v, x, y) { // don't allow isolated tooth of a color
        return cube[y][x-1] == v || cube[y][x+1] == v || cube[y-1][x] == v || cube[y+1][x] == v
    }
    var didSomething = false;
    for(var ti in teeth) {
        var t = teeth[ti]
        if (x == t.x && y == t.y) {
            do {
                cube[y][x] = (cube[y][x] + 1) % 7
            } while(!t.p.includes(cube[y][x]) || !hasSameNei(cube[y][x], x, y))
            didSomething = true;
            break
        }
    }
    if (!didSomething)
        return;
    paintCube()
    readCube(editingCubeId)
    
    newRestart()
}

function triggerEditDone()
{
    if (editingCubeId == -1)
        throw "Unexpected cube-id"

    triggerCubeEdit(false) // remove the dialog
}

function changeColor(colors, mode, options) 
{
    if (options.input.value == options.input.prevValue)
        return
    options.input.prevValue = options.input.value
    if (options.input == editBackColor)
        colorBack = colors
    else if (options.input == editFrontColor)
        colorFront = colors
        
    makeColoredTex()   
    paintCube()
    sentTexParam()
}

function isColorsBlack() {
    if (editBlackSel.value == 'white')
        return true
    if (editBlackSel.value == 'normal')
        return false
    // 'auto'    
    var bl = colorBack.rgbaMixWhite.luminance
    var fl = colorFront.rgbaMixWhite.luminance

    // in case of textured draw, I assume the back color represents the piece color
    if (editFillColorRadio.checked || editFillTextureRadio.checked)
        return bl < 0.05
    else if (editFillMarbleRadio.checked || editFillMixRadio.checked)
        return (bl < 0.1 && fl < 0.1) || bl < 0.05 || fl < 0.05 // either one of them is really dark or both kinda dark
    return false // shouldn't happen
}

function sentTexParam() {
    textureParamCube(editingCubeId, drawType, colorBack.rgb.r, colorBack.rgb.g, colorBack.rgb.b, 
                                              colorFront.rgb.r, colorFront.rgb.g, colorFront.rgb.b, isColorsBlack())
}

function triggerEditTexture()
{
    loadTexImage("http://localhost:8000/emscripten/test_texture3.png")
    //loadTexImage("http://i.imgur.com/dPY5gPe.png") 
    //loadTexImage("http://i.imgur.com/gIcxWPI.png")    // transparent
    
    //loadTexImage(blank_tex)
    
    if (drawType == DRAW_TEX)
        editImg = loadedImg; 
}

var baseFramePicPos = [ [1,1], [1,5], [5,1], [5,5], [9,1], [9,5] ]
var cubeTexInfo = []

function sendTexCoord()
{
    if (editImg === null)
        return
    var imgRatio = (editImg.height/editImg.width) / ((editCanvas.height- 2*EDIT_MARGIN)/(editCanvas.width- 2*EDIT_MARGIN))

    cubeTexInfo = []
    for(var i = 0; i < 6; ++i) {
        var x = baseFramePicPos[i][0] / (15*imgZoom)  - imgOffset.x / ((editCanvas.width - 2*EDIT_MARGIN)*imgZoom)
        var y = baseFramePicPos[i][1] / (11 * imgRatio*imgZoom) - imgOffset.y / ((editCanvas.height - 2*EDIT_MARGIN) * imgRatio*imgZoom)
        
        cubeTexInfo.push({x:x, y:y, scaleX:5/(15*imgZoom), scaleY:5/(11*imgRatio*imgZoom) })
    }
    readCubeTexCoord(editingCubeId) // reads from cubeTexInfo
}

function triggerAction(bpr)
{
    if (bpr == 1) {
        if (editActionPiecesCheck.checked) {
            editActionMoveCheck.checked = false
        }
    }
    else {
        if (editActionMoveCheck.checked) {
            editActionPiecesCheck.checked = false
        }
    }
}

function changeImgZoom(widget, v)
{
    if (widget == 1) { // slider changed
        editZoomText.value = v + "%"
    }
    else { // edit changed
        editZoomSlider.value = v
    }
    imgZoom = v / 100.0
    
    paintCube()
    sendTexCoord()
}



function changeFillSelect(dtype)
{
    if (drawType == dtype)
        return;
    drawType = dtype
    switch(drawType) 
    {
    case DRAW_COLOR: editImg = null; current_src = null; break
    case DRAW_PROFI: editImg = null; current_src = src_profi; break
    case DRAW_MARBLE: editImg = null; current_src = src_marble; break
    case DRAW_TEX: 
        if (loadedImg == null)
            loadTexImage(blank_tex)
        editImg = loadedImg; 
        current_src = null; 
        break
    }
    makeColoredTex()
    paintCube()
    sentTexParam()
    if (drawType == DRAW_TEX)
        newRestart()  // setting individual half need a new solution with all textures out
}

function triggerBlackSel()
{
    paintCube()
    sentTexParam()
}
    
</script>
<script src="js_main.js"></script>
<style>
body {
    margin: 0;
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
     user-select: none;
    background: #b2b2b2; 
}
#mycanvas {
    margin: 8px 0 0 8px;
    
}
#side_ctrl {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 230px;
    background: #cbcfff;
    margin-top: 8px;
    margin-bottom: 8px;
    overflow:hidden;
    border-radius: 8px 0 0 8px;
}
.toppic {
    margin: 5px 5px 5px 7px;
    background: #eeeeff;
    font-family: Verdana;
    padding: 4px;
    border-radius: 5px;
    transition: height 0.2s ease-in-out;
    height: 26px;
    
}
.in_rel {
    position:relative; 
    width:100%; 
    top: 100px;
    bottom: 20px;
    overflow: hidden;
}
.toppic_icon {
    float: right;
    padding: 3px 0 3px 0;
}
.inframe {
    display: block;
    visibility: hidden;
    position: relative;
    opacity: 0;
    transition: all 0.2s ease-in-out;
}
.cube_count {
    display: none; /* start retracted */
}
.piccube {
    height: 26px;
    line-height: 26px; /* vertical align */
    background: #ffffff;
    padding: 6px;
    margin:4px;
    
    border-radius: 5px;
}
.famtitle {
    height: 26px;
    line-height: 26px;
}

@keyframes rotate180 {
    0%   {transform: rotate(0deg);}
    100% {transform: rotate(180deg);}
}
.arrowAnimUp {
    animation-name: rotate180;
    animation-duration: 0.2s;
}
.arrowAnimDown {
    animation-name: rotate180;
    animation-duration: 0.2s;
    animation-direction: reverse;
}
.arrowUpsideDown {
    transform: rotate(180deg);
}
.fam_check {
    width: 17px;
    height: 17px;
    margin: -4px 4px 0 2px;
    vertical-align: middle;
}
.fam_label {
    display:inline-block;
    width: 160px;
}
.cube_check {
    width: 17px;
    height: 17px;
    vertical-align: middle;
    margin: -4px 7px 0 0
}
.cube_count {
    position: absolute;
    right: 12px;
    width: 50px;
    height: 17px;
    padding: 2px 0 2px 0;
    text-align: center;
}
#stat {
    position: absolute;
    bottom: 8px;
    left: 8px;
}

.mycheck_label {
    background-image: url(check_none.png);
    display: inline-block;
}
.mycheck_checked {
    background-image: url(check_checked.png);
}
.mycheck_inter {
    background-image: url(check_int.png);
}

/*------------------------------------------------------------*/
.hidden {
    position:absolute;
    z-index:-1;
    }
.sc-btn {
  display: inline-block;
  position: absolute;

  font-family: "Helvetica Neue", "Helvetica", sans-serif;

  border-radius: 0.4em;

  box-shadow: inset rgba(0, 0, 0, 0.1) 0px -0.15em 0px, inset rgba(255, 255, 255, 0.2) 0px 0.15em 0px, rgba(0, 0, 0, 0.3) 0px 0.1em 0.3em;
  text-align: center;
  cursor: pointer;
  overflow: hidden; 
  
  color: #222;
  text-shadow: rgba(127, 127, 127, 0.4) 0 1px 0;
  background-color: #ebebeb;
  background-image: linear-gradient(to bottom, white, #ebebeb);   
  
  width: 100px;
  height: 40px;
  line-height: 40px;
  margin: 7px;
  outline:none;  /* no focus outline */
  font-size:110%;
}

.sc-btn:hover {
  color: #222;
  background-color: #d2d2d2;
  background-image: linear-gradient(to bottom, white, #d2d2d2);
  background-color: #fdfdfd;   
}

.sc-btn:active {
    box-shadow: rgba(255, 255, 255, 0.2) 0 0.1em 0, inset rgba(0, 0, 0, 0.3) 0px 0.25em 1em; 
    color: #fff;
    background-color: #dfdfdf;
    background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
}
.sc-btn:checked  {

  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
}



#addingCube {
  background-image: linear-gradient(to bottom, white, #DADAFD);
}
#addingCube:active, #addingCubeCheck:checked + #addingCube{
    color: #fff;
    background-image: linear-gradient(to bottom, #61adf4, #1067c1); 
}
#removingCube {
  background-image: linear-gradient(to bottom, white, #FDDADA);
}
#removingCube {
    left: 115px;
}
#removingCube:active, #removingCubeCheck:checked + #removingCube{
    color: #fff;
    background-image: linear-gradient(to bottom, #f57979, #e32323); 
}

#aboutBtn {
   right: 8px;
   width: 40px;
   bottom: 8px;
}

#urlBtn {
   right: 8px;
   width: 40px;
   bottom: 55px;
   height: 30px;
   background: url(url-icon_s3.png) #ebebeb center no-repeat;
}


.popupBack {
    display: none;
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(20,20,20, 0.82);
    top: 0;
    left: 0;
}
.popupWin {
    position: absolute;
    width: 600px;
    height: 460px;
    top: 25%;
    left: 0;
    right: 0;
    margin-left: auto;
    margin-right: auto;
    background: #FFF;
    border-radius: 15px;
    padding: 20px;
}

h1, h2, h3 {
    margin: 0;
    font-family: Tahoma;
}
h3 {
    font-size: 12px;
    font-family: monospace;
    margin: 30px 0 0 0;
}
h2 {
    font-size: 20px;
}
h1 {
    font-size: 30px;
    margin: 0 0 0 30px;
}
#urlPopup {
    position: absolute;
    bottom: 100px;
    right: 16px;
    width: 300px;
    height: 36px;
    background: #ededed;
    border-radius: 6px;
    border: 1px outset #A9A7A7;
    visibility: hidden;
}
#urlEdit {
    height: 20px;
    margin: 5px;
    width: 286px;
    
}

#addFamBtn{
    width: 34px;
    height: 34px;
    margin: 0 7px 7px 7px;
    background: url(plus.png) #ebebeb center no-repeat;
}
.addCubeBtn {
    width: 34px;
    height: 25px;
    left: 150px;
    background: url(plus.png) #ebebeb center no-repeat;
    margin: 0;
}
.linklike {
    cursor: pointer;
    color: blue;
    text-decoration: underline;
}
#picEditWin {
    height: 550px;
}


#editDoneBtn {
   right: 8px;
   width: 60px;
   bottom: 8px;
}

.color {
   padding: .5em;
   margin-right: .4em;
   border: 1px solid #aaa;
   border-radius: 3px;
   width: 140px;
   font-family: monospace;
}

#editTexBtn {
   width: 60px;
   
}
#editActionPieces {
    top: 100px;
    right: 40px
}
#editActionPieces:active, #editActionPiecesCheck:checked + #editActionPieces,
#editActionMove:active, #editActionMoveCheck:checked + #editActionMove {
  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
  color: #fff;
}

#editActionMove {
    top: 150px;
    right: 40px
}

#editBackColor {
    position: absolute;
    width: 60px;
    right: 55px;
    top: 260px;
}
#editFrontColor {
    position: absolute;
    width: 60px;
    right: 55px;
    top: 300px;
}
#editBlackSel {
    position: absolute;
    width:90px;
    right: 45px;
    top: 340px;
    height: 26px;
}

#editZoomSlider {
    position: absolute;
    height: 200px;
    width: 40px;
    right: 8px;
    top: 30px;
    -webkit-appearance: slider-vertical;
    writing-mode: bt-lr
}
#editZoomText {
    position: absolute;
    top: 240px;
    width: 40px;
    right: 8px;
    text-align: center;
    height: 20px;
}

.editFillRadio, .editFillLabel {
    font-family: "Helvetica Neue", "Helvetica", sans-serif;
    font-size:110%;
    margin: 6px;
}
#editFillColor {
    top: 400px;
}
#editFillTexture {
    top: 420px;
}
.fillRadio {
    height: 40px;
    width: 180px;
    position: static;
    margin: 1px;
    text-align: left;
    text-indent: 10px;
}
#editFillColor:active,   #editFillColorRadio:checked +   #editFillColor,
#editFillTexture:active, #editFillTextureRadio:checked + #editFillTexture,
#editFillMarble:active,  #editFillMarbleRadio:checked +  #editFillMarble,
#editFillMix:active,     #editFillMixRadio:checked +     #editFillMix {
  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
  color: #fff;
}

</style>
</head>
<body onload="start()" onresize="doResize()" >
    <div id="side_ctrl">
    <input id="addingCubeCheck" class="hidden" onclick="triggerAdd()" type="checkbox">
    <label id="addingCube" class="sc-btn" for="addingCubeCheck" >Add</label>
    <input id="removingCubeCheck" class="hidden" onclick="triggerRemove()" type="checkbox"/>
    <label id="removingCube" class="sc-btn" for="removingCubeCheck"/>Remove</label>
    <label id="aboutBtn" class="sc-btn" onclick="triggerAbout(true)"/>?</label>
    <label id="urlBtn" class="sc-btn" onclick="triggerUrl(true)"/></label>
    <div id="side_rel" class="in_rel">
      <div id="fams_cont"></div>
      <label id="addFamBtn" class="sc-btn" onclick="triggerAddFam()"/></label>
    </div>
    <div id="editBack" class="popupBack"><div id="picEditWin" class="popupWin">
        <canvas id="editCanvas" width="590", height="450"></canvas>
        <label id="editDoneBtn" class="sc-btn" onclick="triggerEditDone()"/>Done</label>
        <label id="editTexBtn" class="sc-btn" onclick="triggerEditTexture()"/>Texture</label>
        <input id="editBackColor" class="color" />
        <input id="editFrontColor" class="color" />
        <select id="editBlackSel" oninput="triggerBlackSel()">
            <option value="auto">Auto Lines</option>
            <option value="normal">Normal Lines</option>
            <option value="white">White Lines</option>
        </select>
        
        <input id="editActionPiecesCheck" class="hidden" onclick="triggerAction(1)" type="checkbox">
        <label id="editActionPieces" class="sc-btn" for="editActionPiecesCheck"/>Edit Pieces</label>
        <input id="editActionMoveCheck" class="hidden" onclick="triggerAction(2)" type="checkbox">
        <label id="editActionMove" class="sc-btn" for="editActionMoveCheck"/>Move Image</label>
        <input id="editZoomSlider" type="range" orient="vertical" min="20" max="200" step="1" oninput="changeImgZoom(1,editZoomSlider.value)"/>
        <input id="editZoomText" type="text" oninput="changeImgZoom(2,parseFloat(editZoomText.value))"/>
        
        <br>
        <input id="editFillColorRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(0)">
        <label id="editFillColor" class ="sc-btn fillRadio" for="editFillColorRadio">Uniform Color</label><br>
        <input id="editFillTextureRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(0x14)">
        <label id="editFillTexture" class ="sc-btn fillRadio" for="editFillTextureRadio">Texture from Image</label><br>
        <input id="editFillMarbleRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(4)">
        <label id="editFillMarble" class ="sc-btn fillRadio" for="editFillMarbleRadio">Marble Texture</label><br>
        <input id="editFillMixRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(2)">
        <label id="editFillMix" class ="sc-btn fillRadio" for="editFillMixRadio">Mix Texture</label><br>

        <img id="edit_marble" src="bw_marble3_sm.jpg" style="display:none;"/>
        <img id="edit_profi" src="bw_profi2_sm.jpg" style="display:none;"/>
        <canvas id="canvas_marble" style="display:none;"></canvas>
        <canvas id="canvas_profi" style="display:none;"></canvas>

    </div></div></div>
    </div>
    <div id="urlPopup"><input id="urlEdit" type="text" onchange="urlEditChanged()"/></div>
    
    <canvas id="mycanvas" width="800" height="700"></canvas>
    
    <div id="aboutBack" onclick="triggerAbout(false)" class="popupBack"><div id="aboutWin" class="popupWin">
    <h1>Happy Cube Solver</h1><br>
    <h2>Designed and implemented by Shy Shalom (1995 - 2016)<br>
    <a href="mailto:shooshx@gmail.com" target="_blank">shooshx@gmail.com</a><br></h2>
    <h3>Using this program automatically implies that you respect the copyrights on the Happy Cube&copy;&reg; Puzzles.<br>
This program is indented to support you while playing live with the Happy Cube&copy;&reg; Puzzles. These puzzles are worldwide manufacturered by HAPPY bvba, Belgium, on licensed and thus restricted base (<a href="http://www.happy.be" target="_blank" id="linka">www.happy.be</a>). The Happy Cube puzzles are the result of a real invention in 1986 by Dirk Laureyssens. This means that using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law, since the Happy Cube Puzzles are worldwide protected by many US copyrights since 1987.<br>
Please note that using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law, since the Happy Cube&copy;&reg; Puzzles are worldwide protected by US copyrights since 1987.<br>
Puzzles copyright (C) Dirk Laureyssens 1986-2016. All rights reserved. The Happy Cube puzzles are protected with several US copyrights since 1987 (TXU 271722, TX2332525, TX2359816 and many others). They are exclusively manufactured by Happy bvba, B-2980 Zoersel, Belgium, and distributed worldwide by partners. Using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law. 
Happy Cube, Little Genius, Profi Cube and Marble Cube are registered trademarks of Happy bvba, Zoersel, Belgium. 
If you have any questions concerning the usage of HAPPY materials, please send your detailed request in writing to <a href="mailto:info@happy.be" target="_blank">info@happy.be</a>. See <a href="http://www.happy.be" target="_blank">http://www.happy.be</a> for more information</h3>
    </div></div>
    
    <img id="noisetex" src='cubeTex.png' style="display:none;"/>
    <img src="arrow_up.png" style="display:none;"/>
    <img src="arrow_down.png" style="display:none;"/>
    <img id="newgenious" src="../new_genious128.png" style="display:none;"/>
    <img id="genious" src="../littlegenious128_2.png" style="display:none;"/>
    <img id="dummy_check1" src="check_int.png" style="display:none;"/> <!-- avoid flicker -->
    <img id="blank_tex" src="blank_tex.png" style="display:none;"/>
    <div id="stat"></div>
</body>
</html>
