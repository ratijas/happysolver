<!doctype html>
<html><head>
<meta charset="UTF-8">
<title>Happy Cube Solver Online</title>
<script>
 /* (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2231125-5', 'auto');
  ga('send', 'pageview');*/
</script>

<link rel="icon" href="favicon.ico" type="image/x-icon"/>
<script id="stdpcs" src="stdpcs.js"></script>  
<script id="unimesh2" src="unified_mesh.js"></script>  
<script id="one_cube" src="one_piece_cube.js"></script>    
<!--<script id="one_cube" src="one_marble_cube.js"></script>    -->

<script type="text/javascript" src="colorPick/color.all.min.js"></script> <!-- https://github.com/PitPik/colorPicker  -->
<script type="text/javascript" src="colorPick/jsColor.js"></script>

<script type="text/javascript">
"use strict"

// unified_mesh.js
// j_unified_meshes_all.txt
    
var gl = null
var prog = null
var model = { vtxBuf: null }

var loadSolution, resizeGl, mouseUp, mouseDown, mouseMove, mouseDblClick, mouseWheel, cpp_draw, cpp_slvrun, getTms
var setGrpCount, setEditAction, runningRestart, serializeCurrent, deserializeAndLoad, readCubeFromEditor, newRestart, conf
var stackState, textureParamCube, getCubeTextureHandle, readCubeTexCoord, loadSlvSimple, freeMeshAllocator
var readCubeToEditor, textureParamToEditor, getToothPossibilities, solveGo
var ctrlPressed = false
var editCtx = null
var unimesh_keys = Object.keys(unimesh) // unimesh included above
var readFrameBuf = null, readFrameView = null // buffer for selection readPixels. don't want it managed by emscripten

var ACT_NONE = 0, ACT_ADD = 1, ACT_REMOVE = 2

var colorPickCfg = null 
    
function start() 
{
    colorPickCfg = {
        customBG: '#222',
        readOnly: true,
        // patch: false,
        init: function(elm, colors) { // colors is a different instance (not connected to colorPicker)
          elm.style.backgroundColor = elm.value;
          // used to be rgbaMixCustom the color mixed with the customBG color (not relevant for me since alpha is 1.0 always)
          elm.style.color = colors.rgbaMixWhite.luminance > 0.22 ? '#222' : '#ddd';
        },
        initStyle: 'display: hidden',
        mode: 'hsv-h',
        noAlpha: true,
        size: 1,
        appendTo: editBack,
        displayCallback:changeColor,
        multipleInstances:true
    }
    jsColorPicker('input.color', colorPickCfg);
    
  /*  picsAddFamily("Happy Cube", "hc")
    picsAddCube("Blue", "hc_blue")
    picsAddCube("Red", "hc_red")
    picsAddCube("Purple", "hc_purple")
    picsAddFamily("Profi Cube", "pc")
    picsAddCube("AAAA", "pc_aaa")
    picsAddCube("BBBB", "pc_bbbb")
    //return
*/

    loadSolution = Module.cwrap('loadSolution', null, ['string'])
    resizeGl = Module.cwrap('resizeGl', null, ['number', 'number'])
    mouseDown = Module.cwrap('mouseDown', null, ['number', 'number', 'number'])
    mouseUp = Module.cwrap('mouseUp', null, ['number'])
    mouseMove = Module.cwrap('mouseMove', null, ['number', 'number', 'number', 'number'])
    mouseDblClick = Module.cwrap('mouseDblClick', null, ['number', 'number', 'number'])
    mouseWheel = Module.cwrap('mouseWheel', null, ['number'])
    cpp_draw = Module.cwrap('cpp_draw', 'boolean', ['number'])
    cpp_slvrun = Module.cwrap('cpp_slvrun', 'boolean', [])
    getTms = Module.cwrap('getTms', 'number', [])
    solveGo = Module.cwrap('solveGo', null, [])
    setGrpCount = Module.cwrap('setGrpCount', null, ['number', 'number'])
    setEditAction = Module.cwrap('setEditAction', null, ['number'])
    runningRestart  = Module.cwrap('runningRestart', null, [])
    serializeCurrent  = Module.cwrap('serializeCurrent', 'number', [])
    deserializeAndLoad = Module.cwrap('deserializeAndLoad', null, ['number'])
    readCubeFromEditor = Module.cwrap('readCubeFromEditor', null, ['number'])
    newRestart  = Module.cwrap('newRestart', null, [])
    conf = Module.cwrap('conf', null, ['number'])
    stackState = Module.cwrap('stackState', null, ['number'])
    textureParamCube = Module.cwrap('textureParamCube', null, ['number','number','number','number','number','number','number','number','number',
                                                                // grpi,drawtype,r,g,b,r,g,b,isBlack
                                                               'string', 'string', 'string', 'number', 'string']) 
                                                               // back-hex, front-hex, black-selector, rot-angle, url
    getCubeTextureHandle = Module.cwrap('getCubeTextureHandle', 'number', ['number', 'number', 'number'])
    readCubeTexCoord = Module.cwrap('readCubeTexCoord', null, ['number'])
    loadSlvSimple = Module.cwrap('loadSlvSimple', null, ['string'])
    freeMeshAllocator = Module.cwrap('freeMeshAllocator', null, [])
    readCubeToEditor = Module.cwrap('readCubeToEditor', null, ['number', 'string'])
    textureParamToEditor = Module.cwrap('textureParamToEditor', null, ['number'])
    getToothPossibilities = Module.cwrap('getToothPossibilities', null, ['number', 'number'])

    
   
    Module.ccall('cpp_start', null);
    conf(true)
    Module.ccall('initCubeEngine', 'boolean', ['string', 'number'], [stdpcs_text, 0])
    
    loadSolution(one_piece_cube_text)
    //loadSolution(one_marble_cube_text)

    if (window.location.search.length > 0) {
        loadUrl(window.location.toString())
    }

    //solveGo()
    
    doResize();
    //resize(mycanvas.width, mycanvas.height)
    
    mycanvas.onmousedown = handleMouseDown
    document.onmouseup = handleMouseUp
    document.onmousemove = handleMouseMove
    mycanvas.ondblclick = handleMouseDblClick
    mycanvas.onwheel = mycanvas.onmousewheel = handleMouseWheel // second one is for internet explorer
    editCanvas.onclick = handleEditCanvasClick
    //editCanvas.onmousemove = handleEditCanvasMove
    editCanvas.onmousedown = handleEditCanvasDown
    
    document.onkeydown = handleKeyDown
    document.onkeyup = handleKey  

    editFileInput.value = "" // firefox retains the value from last session
    editFileName.value = ""
   
    // start drawing
    requestAnimationFrame(animProgress)
    setInterval(sampleTms, 1000)
    
    addingCubeCheck.checked = true
    setCheck(addingCube, true)
    removingCubeCheck.checked = false
    setCheck(removingCube, false)
    setEditAction(ACT_ADD) 
    
    // editor init
    editCtx = editCanvas.getContext("2d")
    blank_tex.loadedOk = true


    picsAddFamily("Test Fam", "Test Fam", true)
    picsAddCube("Test Cube", "Test Cube", -1, true)
    
    
}

var pressedInCanvas = false
function handleMouseDown(event) {
    pressedInCanvas = true
    mouseDown( (event.button == 2)?1:0, event.clientX, event.clientY)
    //return false
}
function handleMouseUp(event) {
    pressedInCanvas = false
    mouseUp( (event.button == 2)?1:0)
    // returning false here breaks the spinbox
    //return false
}
var lastX = null, lastY = null
function handleMouseMove(event) {
    if (lastEditDrag)
        return handleEditCanvasMove(event)
    if (event.clientX == lastX && event.clientY == lastY)
        return false; // for some reason this event arrives in clicks as well
    lastX = event.clientX
    lastY = event.clientY
    var but = event.buttons
    if (but === undefined)
        but = event.which // for safari

    if (but != 0 && !pressedInCanvas)
        return true// if pressed, avoid reacting to pressed move outside the canvas (editor)
        
    mouseMove(but, ctrlPressed?1:0, event.clientX, event.clientY)
    return false
}
function handleMouseDblClick(event) {
    mouseDblClick(ctrlPressed?1:0, event.clientX, event.clientY);
    return false
}
function handleMouseWheel(event) {
    var d = event.wheelDelta
    mouseWheel( (d > 0) ? 16 : -16)
    return false
}

function handleKeyDown(event) {
    if (event.keyCode == '65' && event.ctrlKey) {
        var s = window.prompt("slv data")
        loadSlvSimple(s)
        return
    }
    handleKey(event)
}

function handleKey(event) {
    if (event.ctrlKey == ctrlPressed)
        return;
    ctrlPressed = event.ctrlKey;
    mouseMove(0, ctrlPressed?1:0, lastX, lastY)
    return false
}

var lastFamAdded = ''
var pics_families = {} // make family id to { cubes: list of { cid: cube-id, grpi: group-index } }
var pics_cubes = {} // make cube id to { famid }
var max_grpi = 0; // the largest cube number we've seen. used for adding more cubes in the ui

function picsAddFamily(famName, id, editable) {
    id = id.replace(/[-\. ]/g, '_')
    var editTag = ''
    if (editable) {
        editTag = '<label class="addCubeBtn sc-btn" title="Add Cube" onclick="triggerAddCube(\'ID\')"/><span class="addCubeBtnIn"></span></label>'
    }
    var picsCtrl = '<div id="ID_frame" class="toppic"><div class="famtitle">\
    <input class="fam_check_box hidden mycheck" id="ID_fcheck" type="checkbox" onchange="on_fam_check(\'ID\', ID_fcheck.checked, true);setCheck(ID_fcheck_label, ID_fcheck.checked)" />\
    <label class="fam_check mycheck_label" id="ID_fcheck_label" for="ID_fcheck" ></label>ADDEDIT\
    <div class="fam_label" onclick="pic_rolldown(\'ID\')">LABEL</div>\
    <img class="toppic_icon" id="ID_img" src="arrow_up.png" onclick="pic_rolldown(\'ID\')"></div> \
    <div id="ID_famframe" class="inframe"></div> \
    </div>'.replace(/ADDEDIT/g, editTag).replace(/ID/g, id).replace(/LABEL/g, famName)

    var dummy = document.createElement("DIV")
    dummy.innerHTML = picsCtrl;
    fams_cont.appendChild(dummy.firstChild) // this way I avoid recreating the whole panel each time and making the selection invalid (as opposed to .innerHTML +=)
    
    lastFamAdded = id
    pics_families[id] = { cubes: []}
    
}
function picsAddCube(cubeName, id, grpi, editable) {
    if (grpi == -1)
        grpi = max_grpi + 1
    id = id.replace(/[-\. ]/g, '_')
    var editStart = '', editEnd = ''
    if (editable) {
        editStart = "<span class='linklike' onclick=triggerCubeEdit(true,INDEX)>"
        editEnd= "</span>"
    }
    var txt = '<div id="ID_inframe" class="piccube">\
    <input class="cube_check_box hidden mycheck" id="ID_ccheck" type="checkbox" onchange="on_cube_check(\'ID\', ID_ccheck.checked, INDEX);setCheck(ID_ccheck_label, ID_ccheck.checked)"/>\
    <label class="cube_check mycheck_label" id="ID_ccheck_label" for="ID_ccheck" ></label>EDITSTARTLABELEDITEND\
    <input class="cube_count" id="ID_ccount" type="number" min="0" onchange="on_cube_count(\'ID\', INDEX)">\
    </div>'.replace(/EDITSTART/g, editStart).replace(/EDITEND/g, editEnd).replace(/ID/g, id).replace(/LABEL/g, cubeName).replace(/INDEX/g, grpi)
    
    var dummy = document.createElement("DIV")
    document.getElementById(lastFamAdded + "_famframe").innerHTML += txt
    pics_families[lastFamAdded].cubes.push( { cid: id, grpi: grpi})
    pics_cubes[id] = { famid: lastFamAdded }
    
    if (grpi > max_grpi)
        max_grpi = grpi
}

// update the cube count after a check is changed. v is boolean for the value of the check
function dispCCount(id, v, gind) {
    var ccount = document.getElementById(id + "_ccount")
    ccount.style.display = (v ? "inline":"none")
    if (v && ccount.value <= 0)
        ccount.value = 1
    
    if (v)
        setGrpCount(gind, ccount.value)
    else
        setGrpCount(gind, 0)
}

function setCheck(idlabel, v) {
    idlabel.classList.remove('mycheck_inter')
    if (v === true)
        idlabel.classList.add('mycheck_checked')
    else if (v === false)
        idlabel.classList.remove('mycheck_checked')
    
}
function setIntermediate(idlabel, v) {
    if (v === true)
        idlabel.classList.add('mycheck_inter')
    else if (v === false)
        idlabel.classList.remove('mycheck_inter')
}


function on_fam_check(id, v, doSolve) {
    var fcubes = pics_families[id].cubes;
    for(var i in fcubes) {
        var c = fcubes[i]
        document.getElementById(c.cid + "_ccheck").checked = v
        setCheck(document.getElementById(c.cid + "_ccheck_label"), v)
        dispCCount(c.cid, v, c.grpi)
    }
    if (doSolve) // on inialization select, don't want to do this
        runningRestart()
}

// from C++ on initialization. just need to take care of the checkboxes and count display. the counts are already there
function setFamCheck(id, v) {
    document.getElementById(id + "_fcheck").checked = v
    setCheck(document.getElementById(id + "_fcheck_label"), v)
    on_fam_check(id, v, false)
}

function picFamCheck(id) {
    var famid = pics_cubes[id].famid
    var fcubes = pics_families[famid].cubes;
    var allTrue = true, allFalse = true
    for(var i in fcubes) {
        var cid = fcubes[i].cid
        var iv = document.getElementById(cid + "_ccheck").checked

        allTrue = allTrue && iv
        allFalse = allFalse && !iv
    }
    var famCheck = document.getElementById(famid + "_fcheck")
    var famLabel = document.getElementById(famid + "_fcheck_label")
    famCheck.indeterminate = false
    if (allTrue) {
        famCheck.checked = true
        setIntermediate(famLabel, false)
        setCheck(famLabel, true)
    }
    else if (allFalse) {
        famCheck.checked = false
        setIntermediate(famLabel, false)
        setCheck(famLabel, false)
    }
    else {
        famCheck.indeterminate = true   
        setCheck(famLabel, false)
        setIntermediate(famLabel, true)
    }
}

function on_cube_check(id, v, gind) {
    dispCCount(id, v, gind)
    picFamCheck(id)
    runningRestart()
}

function on_cube_count(id, gind) {
    var ccount = document.getElementById(id + "_ccount")
    var ccheck = document.getElementById(id + "_ccheck")
    var clabel = document.getElementById(id + "_ccheck_label")
    var prevCh = ccheck.checked, newCh = (ccount.value > 0)
    //console.log("COUNT " + prevCh + " " + newCh)
    if (prevCh != newCh) {
        ccheck.checked = newCh
        setCheck(clabel, newCh)
        picFamCheck(id)
    }
    setGrpCount(gind, ccount.value)
    runningRestart()
}

// obj is the int handle of the opengl object
function registerTexBind(imgname, obj) {
    //console.log("reg-tex " + imgname + " " + obj)

    var img = document.getElementById(imgname)
    _glBindTexture(GLctx.TEXTURE_2D, obj)
    GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, img)
}

function requestAnim() {
    requestAnimationFrame(animProgress)
}

function animProgress() {
    var again = cpp_draw(0.2);
    if (again)
        requestAnimationFrame(animProgress)
    
}

var enterSlv = false

function requestSlvRun() {
    setTimeout(slvRun, 0)
    enterSlv = true
}



function slvRun() {
    if (!enterSlv)
        return
    setTimeout(slvRun, 0)  // pre-schedule the next time to avoid delay
    enterSlv = cpp_slvrun()
    //if (again)
    //    setTimeout(slvRun, 0)
    
}

var lastTms = 0
function sampleTms() {
    var tms = getTms()
    var delta = tms - lastTms
    if (delta != 0)
        stat.innerHTML = "" + delta
    lastTms = tms
}



function pic_rolldown(id) {
    var outframe = document.getElementById(id + '_frame')
    var elem = document.getElementById(id + '_famframe')
    var elemImg = document.getElementById(id + '_img')
    
    // roll up anything else that is rolled down
    for(var fid in pics_families) {
        if (fid == id)
            continue
        if (document.getElementById(fid + '_famframe').isOpen) {
            pic_rolldown(fid)
        }
    }
    
    if (elem.isOpen) {
        elem.isOpen = false
        //  elem.style.display = 'none'
        outframe.style.height = "26px";
        elem.style.visibility = 'hidden'
        elem.style.opacity = 0.0

        elemImg.classList.remove('arrowAnimUp')
  
        var newone = elemImg.cloneNode(true); // restart the animation
        elemImg.parentNode.replaceChild(newone, elemImg);
        
        newone.classList.add('arrowAnimDown')
        newone.classList.remove('arrowUpsideDown')
    }
    else {
        elem.isOpen = true
        //  elem.style.display = 'block'
        outframe.style.height = "283px";
        elem.style.visibility = 'visible'
        elem.style.opacity = 1.0
        
        elemImg.classList.remove('arrowAnimDown')

        var newone = elemImg.cloneNode(true);
        elemImg.parentNode.replaceChild(newone, elemImg);

        newone.classList.add('arrowAnimUp')
        newone.classList.add('arrowUpsideDown')
    }
}


function doResize() {
    if (side_ctrl.editMode)
        side_ctrl.style.width = Math.max(window.innerWidth*0.5, 650) + "px"
    mycanvas.width = window.innerWidth - side_ctrl.clientWidth - 16
    mycanvas.height = window.innerHeight - 16
    side_rel.style.height = "" + (window.innerHeight - 220) + "px"
    picEditWin.style.top = (side_ctrl.clientHeight - picEditWin.clientHeight) * 0.5 + "px"
    
    resizeGl(mycanvas.width, mycanvas.height)
    requestAnim()
}

function triggerAdd() {
    if (addingCubeCheck.checked) {
        removingCubeCheck.checked = false
        setEditAction(ACT_ADD) 
    }
    else {
        setEditAction(ACT_NONE)
    }
}
function triggerRemove() {
    if (removingCubeCheck.checked) {
        addingCubeCheck.checked = false
        setEditAction(ACT_REMOVE)
    }
    else {
        setEditAction(ACT_NONE)
    }

}

function triggerAbout(v) {
    aboutBtn.checked = v
    if (v) {
        aboutBack.style.display = "inline"
    }
    else {
        aboutBack.style.display = "none"
    }
    
    aboutWin.onclick = function(e) {
        e.stopPropagation()
    }
}


var scratchArr = []

function bufferToBase64(buf) {
    var binstr = Array.prototype.map.call(buf, function (ch) {
        return String.fromCharCode(ch);
    }).join('');
    return btoa(binstr);
}

function base64ToBuffer(base64) {
    try {
        var binstr = atob(base64);
        var buf = new Uint8Array(binstr.length);
        Array.prototype.forEach.call(binstr, function (ch, i) {
          buf[i] = ch.charCodeAt(0);
        });
        return buf;
    } catch(err) {
        return "";
    }
}

function triggerUrl(v) {
    if (urlPopup.style.visibility == "visible") {
        urlPopup.style.visibility = "hidden"
        return
    }
    scratchArr = []
    serializeCurrent()
    var b = bufferToBase64(scratchArr)
    console.log(b)
    urlPopup.style.visibility = "visible"
    var url = window.location.toString()
    var qmark = url.indexOf('?')
    if (qmark > 0)
        url = url.substr(0, qmark)
    urlEdit.value = url + '?l=' + b
    urlEdit.select()
}

//loadUrl("AQoAAAgAQAAAAARAAQAQAAEAEAQAAQAgCARBHXRogCOG8YptBGEKWzg=")
function loadUrl(b) {
    var srchAt = b.indexOf('?l=')
    if (srchAt != -1)
        b = b.substr(srchAt + 3)
    if (b.length == 0)
        return;
    scratchArr = base64ToBuffer(b)
    deserializeAndLoad(scratchArr.length)
}

function urlEditChanged() {
    loadUrl(urlEdit.value)
    urlPopup.style.visibility = "hidden"
}

function triggerAddFam() {
    var famName = window.prompt("Family Name?","");
    picsAddFamily(famName, famName, true)
}

function triggerAddCube(intoFam) {
    var cubeName = window.prompt("Cube Name?","");
    if (cubeName == null || cubeName == "")
        return
    picsAddCube(cubeName, cubeName, -1, true)
}

var cube = [
   // 0,1,2,3,4,5,6,7,8,9,1011121314
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 0
    [ 0,1,1,1,1,1,0,0,0,0,0,0,0,0,0 ], // 1
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 2
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 3
    [ 0,1,1,1,1,1,3,3,3,5,5,5,5,5,0 ], // 4
    [ 0,1,1,1,1,1,4,4,4,6,6,6,6,6,0 ], // 5
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 6
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 7
    [ 0,0,2,2,2,2,4,4,4,6,6,6,6,6,0 ], // 8
    [ 0,0,0,0,0,0,0,0,0,6,6,6,6,6,0 ], // 9
    [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ], // 10
]


var TSZ = 30  // size in pixels of a tooth
var DRAW_COLOR = 0
var DRAW_PROFI = 2
var DRAW_MARBLE = 4
var DRAW_TEX = 0x14

var EDIT_MARGIN = 5

//var col = ['white', '#5555ff', 'red', 'yellow', 'orange', 'green', 'purple']
var loadedImg = null  // the image reference being displayed, the image loaded
var imgOffset = {x:0, y:0} // in pixels
var imgZoom = 1.0
var drawType = DRAW_COLOR
var colorBack = new Colors({color:"#ffffff"})
var colorFront = new Colors({color:"#808080"}) // main init setting that spreads to everywhere else
var fileOpenedButNotUploaded = false
var lastFile = null // file object of the last file that was selected by the user
var lastUrl = null // string the last url that was uploaded or entered by the user
var rotAngle = 0;
var origLoadedImg = null

function drawLine(x, y, w, h) {
    editCtx.beginPath()
    editCtx.moveTo(x, y)
    editCtx.lineTo(x + w, y + h);
    editCtx.stroke();
}

function paintCube()
{
    editCtx.fillStyle = '#fff'
    editCtx.fillRect(0, 0, editCanvas.width, editCanvas.height)
    
    switch(drawType) {
    case DRAW_TEX:
        if (loadedImg) 
        {
            editCtx.fillStyle = '#'+colorBack.colors.HEX
            editCtx.fillRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ) // need to show up below transparent pixels
            
            var cwidth = editCanvas.width - 2*EDIT_MARGIN
            var cheight = cwidth * loadedImg.height / loadedImg.width  // maintain same aspect ratio as the image
            editCtx.drawImage(loadedImg, 0,0, loadedImg.width, loadedImg.height, 
                                       imgOffset.x + EDIT_MARGIN, imgOffset.y + EDIT_MARGIN, cwidth*imgZoom, cheight*imgZoom)
        }
        break
    case DRAW_PROFI:
    case DRAW_MARBLE:
        if (!current_src) // indicates colored_tex is on
            throw "missing current_src"
        editCtx.putImageData(colored_tex, EDIT_MARGIN, EDIT_MARGIN)
        break
    case DRAW_COLOR:    
        editCtx.fillStyle = '#'+colorBack.colors.HEX
        editCtx.fillRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ)
        break
    }
    
    editCtx.strokeStyle = 'black'
    editCtx.lineWidth = 1
    
    // frame
    editCtx.strokeRect(EDIT_MARGIN, EDIT_MARGIN, 15*TSZ, 11*TSZ)

   /* for(var x = 0; x < 15; ++x) {
        for(var y = 0; y < 11; ++y) {
            var v = cube[y][x]
            editCtx.fillStyle = col[v]
            editCtx.fillRect(x * TSZ, y * TSZ, TSZ, TSZ)    
        }
    }*/

    editCtx.strokeStyle = isColorsBlack() ? 'white':'black'
    
    for(var x = 0; x < 15; ++x) {
        for(var y = 0; y < 11; ++y) {
            var v = cube[y][x]
            if (y < 10 && x < 14) {
                if (v != cube[y+1][x]) {
                    drawLine(x * TSZ + EDIT_MARGIN, y * TSZ + TSZ + EDIT_MARGIN, TSZ, 0)
                }
                if (v != cube[y][x+1]) {
                    drawLine(x * TSZ + TSZ + EDIT_MARGIN, y * TSZ + EDIT_MARGIN, 0, TSZ)
                }                
            }
        }
    }
}

function setGlTexture() 
{
    var obj = getCubeTextureHandle(editingCubeId, loadedImg.width, loadedImg.height)
    if (obj == 0)
        return
    console.log("setting img to texture " + obj)
    _glBindTexture(GLctx.TEXTURE_2D, obj)
    GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, loadedImg)
    
    // need to setTexCoord here since the width and height might have changed and we need to recalculate them
    sendTexCoord()
    paintCube()
}


// called with the default image on initialization
function loadTexImage(url, type, opt)
{   
    if (!opt) // keepOrig, ondone, onerr, 
        opt = {}
    if (url.length == 0)
        return
    var onload = function() {
       // loadedImg.loadedOk = true
        if (newImg.width == 1 && newImg.height == 1) 
        { // indicates its an SVG
            // get it again, now as a blob (should come from cache and should not fail)
            var oReq = new XMLHttpRequest();
            oReq.open("GET", url, true);
            oReq.responseType = "arraybuffer";
            oReq.onload = function(oEvent) 
            {
                var blob = new Blob([new Uint8Array(oReq.response, minimalPng.length)], {type: "image/svg+xml"});
                loadTexImageBlob(blob, opt)
            };
            oReq.send()
            return
        }
        
        // if an SVG is smaller than 1500px, draw it on the scratch canvas to scale it and take that as the image
        var f = 1500 / newImg.width
        if (type == "image/svg+xml" && f > 1) 
        {
            canvas_scratch.width = 1500
            canvas_scratch.height = newImg.height/newImg.width*1500
            var ctx = canvas_scratch.getContext('2d')
            ctx.drawImage(newImg, 0, 0, canvas_scratch.width, canvas_scratch.height)
            var durl = canvas_scratch.toDataURL("image/png")
            loadTexImage(durl, "image/png", opt)            
            return
        }
        
        if (!opt.noCommit) {
            loadedImg = newImg // switch to the new image
            setGlTexture()
        }
        if (!opt.keepOrig) // default is false, don't keep the original (only needed on rotate)
            origLoadedImg = newImg
        if (opt.ondone)
            opt.ondone()
    }

    var newImg = new Image()

    newImg.onload = onload
    newImg.onerror = function(e) {
        if (opt.onerr)
            opt.onerr()
        console.log("IMAGE-LOAD-ERR")
        resetErrMsg("Failed loading image")
    }
    newImg.crossOrigin = ''
    newImg.src = url
    
}

var editingCubeId = -1
var src_marble = null, src_profi = null // ImageData of the B&W images
var current_src = null // select between src_marble or src_profi or null
var colored_tex = null // resulting colored image that will be displayed (tinted in makeColoredTex)

function makeColoredTex()
{
    if (current_src == null)
        return
    var dst = colored_tex.data
    var src = current_src.data
    var fr = colorFront.colors.rgb.r, fg = colorFront.colors.rgb.g, fb = colorFront.colors.rgb.b
    var br = colorBack.colors.rgb.r, bg = colorBack.colors.rgb.g, bb = colorBack.colors.rgb.b
    for (var i = 0; i < dst.length; i += 4) 
    {
        var g = src[i]
        var rg = 255-g
        dst[i]     = br * g + fr * rg  // red
        dst[i + 1] = bg * g + fg * rg // green
        dst[i + 2] = bb * g + fb * rg // blue
        dst[i + 3] = 255;
    }
}


function triggerCubeEdit(v, cubeId) // cube link pressed or Done pressed
{
    if (v) 
    {
        editBack.style.display = "inline"
        side_ctrl.editMode = true // for resize
        doResize()
        editActionPiecesCheck.checked = true
        editActionMoveCheck.checked = false
        

        editCanvas.height = 11*TSZ + 2*EDIT_MARGIN
        editCanvas.width = 15*TSZ + 2*EDIT_MARGIN
        
        setEditAction(ACT_NONE) // prevent hovering on the cube from editing

        editingCubeId = cubeId
        stackState(0) // push and clear
        conf(false) // make it not randomized so that the solution would be more or less the same
        
        readCubeToEditor(editingCubeId, "ab1255a96529b5522b")  // from grp or default to the editor
        readCubeFromEditor(editingCubeId) // first update of the grp pieces (if this is the first time)

        setGrpCount(editingCubeId, 1) // set it to be selected, need to be here after the parts were added from the editor

        // read from grp color, drawType, black select
        textureParamToEditor(editingCubeId);
        editFileName.value = lastUrl
        
        switch(drawType) { // needs to be before doing any paintCube because that would fail about current_src
        case DRAW_TEX:    editFillTextureRadio.checked = true; break;
        case DRAW_PROFI:  editFillMixRadio.checked = true; break
        case DRAW_MARBLE: editFillMarbleRadio.checked = true; break
        case DRAW_COLOR:  editFillColorRadio.checked = true;  break    
        }
        
        var doColor = function(c, ed, def, idx) {
            if (isNaN(c.colors.rgb.r))  // grp had an empty string for color, take the default
                c.setColor(def)
            ed.value = '#' + c.colors.HEX
            colorPickCfg.init(ed, c.colors);
            if (window.jsColorPicker.colorPickers[idx]) // set the picker popup to the right position according to the color
                window.jsColorPicker.colorPickers[idx].setColor(c.colors.HEX, undefined, undefined, true) // forceRender
        }
        
        doColor(colorBack, editBackColor, '#ffffff', 0)
        doColor(colorFront, editFrontColor, '#808080', 1)
       
        
        updateForDrawType() // needs to be after the setting of the colors (going to mix them) but before loadTexImage
        
        // something to show in the mean time while the url is downloading
        // do the texture loading anyway no depending on drawType since we might return to textur any time
        loadedImg = blank_tex
        origLoadedImg = loadedImg 
        setGlTexture()            
        var mtype = mimeTypeByExt(lastUrl)
        loadTexImage(lastUrl, mtype, { noCommit: true, ondone: function() { // lastUrl was set by the above call
            makeTransformedImg() // takes rotAngle, sets the image and gl instead of loadTexImage which has noCommit
        }}) 
            
        
        if (editBlackSel.value == '')
            editBlackSel.value = 'auto'
            
        // read from grp image offset and zoom
        //texCoordToEditor(editingCubeId)
        sendTexCoord() // need to actually create the texture coordinates from the imgOffset and imgZoom
        updateZoomValue() 
        
        //loadedImg = null // reset the last image loaded
        //origLoadedImg = null
        
        // transfer the marble,profi images to the canvase so they could be accessed when the time comes
        if (!colored_tex) { // happen only in the first time the dialog opens  - TBD needs to be HIGHER
            var run_image = function(img) {
                canvas_scratch.width = 15*TSZ
                canvas_scratch.height = 11*TSZ
                var ctx = canvas_scratch.getContext('2d')
                ctx.drawImage(img, 0,0)
                return ctx.getImageData(0,0, canvas_scratch.width, canvas_scratch.height)
            }
            src_marble = run_image(edit_marble)
            src_profi = run_image(edit_profi)
            colored_tex = editCtx.createImageData(15*TSZ,11*TSZ)
        }
        
        paintCube()   
        newRestart()        
    }
    else 
    {
        readCubeFromEditor(editingCubeId)
        editingCubeId = -1
        
        freeMeshAllocator()
        conf(true)  // revert back to randomized
        stackState(1) // pop last

        editBack.style.display = "none"
        side_ctrl.style.width = "230px"
        side_ctrl.editMode = false
        doResize()
        if (addingCubeCheck.checked)
            setEditAction(ACT_ADD)
        else if (removingCubeCheck.checked)
            setEditAction(ACT_REMOVE)
    }
}

var lastEditDrag = null
function handleEditCanvasDown(event)
{
    lastEditDrag = {x:event.clientX, y:event.clientY}
}

function handleEditCanvasMove(event)
{
    var curDrag = lastEditDrag
    lastEditDrag = null // manage move selection
    if (!editActionMoveCheck.checked)
        return true
    if (event.buttons != 1 || curDrag == null) // left mouse button
        return true

        
    imgOffset.x += event.clientX - curDrag.x
    imgOffset.y += event.clientY - curDrag.y
    lastEditDrag = {x:event.clientX, y:event.clientY}
    
    paintCube()
    sendTexCoord()
    return false
}

function handleEditCanvasClick(event)
{
    if (editActionPiecesCheck.checked)
        checkToothClick(event)
}
 
var toothScratch = null
 
function checkToothClick(event)
{ 
    var rect = editCanvas.getBoundingClientRect()
    var x = Math.trunc((event.clientX - rect.left - EDIT_MARGIN)/TSZ), y = Math.trunc((event.clientY - rect.top - EDIT_MARGIN)/TSZ)
    //console.log(x + " " + y)
    
    var hasSameNei = function(v, x, y) { // don't allow isolated tooth of a color
        return cube[y][x-1] == v || cube[y][x+1] == v || cube[y-1][x] == v || cube[y+1][x] == v
    }
    var didSomething = false;
    toothScratch = []
    getToothPossibilities(x, y); //  writes toothScratch
    if (toothScratch.length == 0) // didn't find
        return;
    do {
        cube[y][x] = (cube[y][x] + 1) % 7
    } while(!toothScratch.includes(cube[y][x]) || !hasSameNei(cube[y][x], x, y))

    paintCube()
    readCubeFromEditor(editingCubeId)
    
    newRestart()
}

function triggerEditDone()
{
    if (editingCubeId == -1)
        throw "Unexpected cube-id"

    triggerCubeEdit(false) // remove the dialog
}

// callback from color selector
function changeColor(colors, mode, options) 
{
    if (options.input.value == options.input.prevValue)
        return
    options.input.prevValue = options.input.value
    if (options.input == editBackColor)
        colorBack.setColor(colors.HEX)
    else if (options.input == editFrontColor)
        colorFront.setColor(colors.HEX)
        
    makeColoredTex()   
    paintCube()
    sentTexParam()
}

function isColorsBlack() {
    if (editBlackSel.value == 'white')
        return true
    if (editBlackSel.value == 'normal')
        return false
    // 'auto'    
    var bl = colorBack.colors.rgbaMixWhite.luminance
    var fl = colorFront.colors.rgbaMixWhite.luminance

    // in case of textured draw, I assume the back color represents the piece color
    if (editFillColorRadio.checked || editFillTextureRadio.checked)
        return bl < 0.05
    else if (editFillMarbleRadio.checked || editFillMixRadio.checked)
        return (bl < 0.1 && fl < 0.1) || bl < 0.05 || fl < 0.05 // either one of them is really dark or both kinda dark
    return false // shouldn't happen
}

function sentTexParam() {
    textureParamCube(editingCubeId, drawType, colorBack.colors.rgb.r, colorBack.colors.rgb.g, colorBack.colors.rgb.b, 
                                              colorFront.colors.rgb.r, colorFront.colors.rgb.g, colorFront.colors.rgb.b, 
                                              isColorsBlack(), 
                                              colorBack.colors.HEX, colorFront.colors.HEX, editBlackSel.value, rotAngle, lastUrl) // things saved for the editor
}

// a minimal 1x1 SVG file 
var minimalPng = new Uint8Array([
	0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
	0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
	0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4, 0x89, 0x00, 0x00, 0x00,
	0x13, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0x62, 0xF8, 0xFF, 0xFF, 0x3F,
	0x03, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x08, 0xFC, 0x02, 0xFE,
	0xD3, 0xA5, 0x75, 0x61, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44,
	0xAE, 0x42, 0x60, 0x82])
    
// imgur doesn't support svg so I hide the svg in a png by simply concatenating it to its end
function encodePng(ba)
{
    var tmp = new Uint8Array(ba.byteLength + minimalPng.length)
    tmp.set(minimalPng, 0)
    tmp.set(new Uint8Array(ba), minimalPng.length)
    return tmp
}



function triggerEditUpload()
{
    if (editUploadBtn.getAttribute("disabled") == "true" || !lastFile)
        return;
    resetErrMsg()
    var file = lastFile
    var reader = new FileReader();
    reader.onload = function(e) 
    { 
        var req = new XMLHttpRequest();
        
        req.onload = function () {
            console.log(req.responseText)
            var re = JSON.parse(req.responseText)
            editFileName.value = re.data.link
            lastUrl = re.data.link
            sentTexParam() // save that url
            editUploadProgress.style.visibility = "hidden"
            fileOpenedButNotUploaded = false
            updateUploadBtnDisabled()
        }
        req.onprogress = function(e) {
            if (e.total == 0)
                return
            var percentComplete = (e.loaded / e.total)*100; 
            //console.log(percentComplete + "  " + e.loaded + "/" + e.total)
            editUploadProgress.value = percentComplete
        }
        if (req.upload)
            req.upload.onprogress = req.onprogress
        req.onerror = function(e) {
            console.log(e)
            editUploadProgress.style.visibility = "hidden"
        }
    
        req.open("POST", 'https://api.imgur.com/3/image', true)
        req.setRequestHeader("Authorization", "Client-ID 559401233d3e1e6")
        req.setRequestHeader("Accept", 'application/json')
        req.setRequestHeader("Content-Type", file.type)
        
        var buf = e.target.result
        if (file.type == "image/svg+xml")
            buf = encodePng(buf)
        req.send(buf)
    
    }
    reader.onerror = function(e) {
        console.log("READER-ERR" + e)
        resetErrMsg("Failed Upload!")
    }
    
    editUploadProgress.value = 0
    editUploadProgress.style.visibility = "visible"
    reader.readAsArrayBuffer(file)


    
    //loadTexImage("http://localhost:8000/emscripten/test_texture3.png")
    //loadTexImage("http://i.imgur.com/dPY5gPe.png") 
    //loadTexImage("http://i.imgur.com/gIcxWPI.png")    // transparent
    
    // imgur.com/gDXDY67.png  - noise
    //http://i.imgur.com/P1ecEyR.png  - svg plus
    //http://i.imgur.com/Yjr8XdH.png - svg too small
    
    //loadTexImage(blank_tex)
}


function loadTexImageBlob(blob, opt)
{    
    var reader = new FileReader();
    reader.onload = function(e) { 
        loadTexImage(e.target.result, blob.type, opt) 
    }
    reader.onerror = function(e) {
        console.log(e)
    }
    reader.readAsDataURL(blob); // read as data URL since we want to put it in an img src
}

function triggerFileChanged()
{
    if (editFileInput.files.length == 0)
        return
    var file = editFileInput.files[0]
    editFileInput.value = null
    lastFile = file

    loadTexImageBlob(file, { ondone:function() {
        // new image from the user - reset parameters
        imgOffset = {x:0, y:0}
        imgZoom = 1
        rotAngle = 0 
        updateZoomValue()
    }})
    
    editFileName.value = file.name
    fileOpenedButNotUploaded = true

    updateUploadBtnDisabled()
    return false
}

var baseFramePicPos = [ [1,1], [1,5], [5,1], [5,5], [9,1], [9,5] ]
var cubeTexInfo = [] // read from c++

function sendTexCoord()
{
    if (loadedImg === null)
        return
    var imgRatio = (loadedImg.height/loadedImg.width) / ((editCanvas.height- 2*EDIT_MARGIN)/(editCanvas.width- 2*EDIT_MARGIN))

    cubeTexInfo = []
    for(var i = 0; i < 6; ++i) {
        var x = baseFramePicPos[i][0] / (15*imgZoom)  - imgOffset.x / ((editCanvas.width - 2*EDIT_MARGIN)*imgZoom)
        var y = baseFramePicPos[i][1] / (11 * imgRatio*imgZoom) - imgOffset.y / ((editCanvas.height - 2*EDIT_MARGIN) * imgRatio*imgZoom)
        
        cubeTexInfo.push({x:x, y:y, scaleX:5/(15*imgZoom), scaleY:5/(11*imgRatio*imgZoom) })
    }
    readCubeTexCoord(editingCubeId) // reads from cubeTexInfo
}

function triggerAction(bpr)
{
    if (bpr == 1) {
        if (editActionPiecesCheck.checked) {
            editActionMoveCheck.checked = false
        }
    }
    else {
        if (editActionMoveCheck.checked) {
            editActionPiecesCheck.checked = false
        }
    }
}

function changeImgZoom(widget, v)
{
    if (widget == 1) { // slider changed
        editZoomText.value = v + "%"
    }
    else { // edit changed
        editZoomSlider.value = v
    }
    imgZoom = v / 100.0
    
    paintCube()
    sendTexCoord()
}

function updateUploadBtnDisabled() {
    var d = drawType != DRAW_TEX || !lastFile || !fileOpenedButNotUploaded
    editUploadBtn.setAttribute("disabled", d) // custom attribute
}

function updateTexDisabledWidgets()
{
    var d = drawType != DRAW_TEX
    editFileButton.disabled = d
    editFileInput.disabled = d
    editFileName.disabled = d

    updateUploadBtnDisabled(d)
    editActionMoveCheck.disabled = d
    if (editActionMoveCheck.checked) {
        editActionMoveCheck.checked = false
        editActionPiecesCheck.checked = true
    }

    editZoomSlider.disabled = d
    editZoomText.disabled = d
    
    editRotR.setAttribute("disabled", d)
    editRotL.setAttribute("disabled", d)
}

function updateZoomValue() {
    editZoomSlider.value = imgZoom * 100
    editZoomText.value = Math.round(imgZoom * 100) + "%"
}

function changeFillSelect(dtype)
{
    if (drawType == dtype)
        return;
    drawType = dtype
    sentTexParam() // send it to grp first so that the following will be able to take care of the tex-coordinates
    updateForDrawType()

    resetErrMsg() // don't want this to stick around after we changed the type
    paintCube()
    if (drawType == DRAW_TEX)
        newRestart()  // setting individual half need a new solution with all textures out
}
    
function updateForDrawType()
{    
    switch(drawType) 
    {
    case DRAW_PROFI: current_src = src_profi; break
    case DRAW_MARBLE: current_src = src_marble; break
    case DRAW_COLOR:
    case DRAW_TEX:   current_src = null; break
    }
    updateTexDisabledWidgets()
    makeColoredTex()
}

function triggerBlackSel()
{
    paintCube()
    sentTexParam()
}

function mimeTypeByExt(fileName) {
    var ext = fileName.substr(fileName.lastIndexOf('.') + 1).toLowerCase();
    var type = ""
    switch (ext) {
    case "png": return "image/png";
    case "jpg": 
    case "jpeg": return "image/jpeg"; 
    case "svg": return "image/svg+xml"; 
    }
    return ""
}

function resetErrMsg(msg) {
    if (msg)
        editErrMsg.innerHTML = msg
    else
        editErrMsg.innerHTML = ""
}

function triggerEditChanged()
{
    var fileName = editFileName.value
    var lowName = fileName.toLowerCase()
    if (!lowName.startsWith("http://") && !lowName.startsWith("https://")) {
        resetErrMsg("Not a well formed URL")
        return
    }
    resetErrMsg()
    var type = mimeTypeByExt(fileName)
    loadTexImage(fileName, type, {ondone:function() {
        lastUrl = fileName // on success, save the entered url
        sentTexParam() // save url
    }, 
    onerr:function() {
        resetErrMsg("Failed Loading")
    }})
    lastFile = null
    updateUploadBtnDisabled()
}



function triggerRotate(dir)
{
    rotAngle = (rotAngle + dir + 4) % 4; // don't allow it to go negative
    sentTexParam()
    makeTransformedImg()
}
    
function makeTransformedImg()
{    
    if (rotAngle == 0) {
        loadedImg = origLoadedImg
        setGlTexture()
        return
    }
    
    if (rotAngle == 1 || rotAngle == 3) {
        canvas_scratch.width = origLoadedImg.height
        canvas_scratch.height = origLoadedImg.width
    }
    else {
        canvas_scratch.width = origLoadedImg.width
        canvas_scratch.height = origLoadedImg.height
    }
    var ctx = canvas_scratch.getContext('2d')
    ctx.setTransform(1,0, 0,1, 0,0)
    ctx.translate(canvas_scratch.width/2, canvas_scratch.height/2);
    ctx.rotate(rotAngle * Math.PI/2);
    ctx.drawImage(origLoadedImg, -origLoadedImg.width/2, -origLoadedImg.height/2);
    
    var url = canvas_scratch.toDataURL("image/png")
    loadTexImage(url, "image/png", {keepOrig:true})

}
    
</script>
<script src="js_main.js"></script>
<style>
body {
    margin: 0;
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
     user-select: none;
    background: #b2b2b2; 
}
#mycanvas {
    margin: 8px 0 0 8px;
    
}
#side_ctrl {
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: 230px;
    background: #cbcfff;
    margin-top: 8px;
    margin-bottom: 8px;
    overflow:hidden;
    border-radius: 8px 0 0 8px;
}
.toppic {
    margin: 5px 5px 5px 7px;
    background: #eeeeff;
    font-family: Verdana;
    padding: 4px;
    border-radius: 5px;
    transition: height 0.2s ease-in-out;
    height: 26px;
    
}
.in_rel {
    position:relative; 
    width:100%; 
    top: 100px;
    bottom: 20px;
    overflow: hidden;
}
.toppic_icon {
    float: right;
    padding: 3px 0 3px 0;
}
.inframe {
    display: block;
    visibility: hidden;
    position: relative;
    opacity: 0;
    transition: all 0.2s ease-in-out;
}
.cube_count {
    display: none; /* start retracted */
}
.piccube {
    height: 26px;
    line-height: 26px; /* vertical align */
    background: #ffffff;
    padding: 6px;
    margin:4px;
    
    border-radius: 5px;
}
.famtitle {
    height: 26px;
    line-height: 26px;
}

@keyframes rotate180 {
    0%   {transform: rotate(0deg);}
    100% {transform: rotate(180deg);}
}
.arrowAnimUp {
    animation-name: rotate180;
    animation-duration: 0.2s;
}
.arrowAnimDown {
    animation-name: rotate180;
    animation-duration: 0.2s;
    animation-direction: reverse;
}
.arrowUpsideDown {
    transform: rotate(180deg);
}
.fam_check {
    width: 17px;
    height: 17px;
    margin: -4px 4px 0 2px;
    vertical-align: middle;
}
.fam_label {
    display:inline-block;
    width: 160px;
}
.cube_check {
    width: 17px;
    height: 17px;
    vertical-align: middle;
    margin: -4px 7px 0 0
}
.cube_count {
    position: absolute;
    right: 12px;
    width: 50px;
    height: 17px;
    padding: 2px 0 2px 0;
    text-align: center;
}
#stat {
    position: absolute;
    bottom: 8px;
    left: 8px;
}

.mycheck_label {
    background-image: url(check_none.png);
    display: inline-block;
}
.mycheck_checked {
    background-image: url(check_checked.png);
}
.mycheck_inter {
    background-image: url(check_int.png);
}

/*------------------------------------------------------------*/
.hidden {
    position:absolute;
    z-index:-1;
    }
.sc-btn {
  display: inline-block;
  position: absolute;

  font-family: "Helvetica Neue", "Helvetica", sans-serif;

  border-radius: 0.4em;

  box-shadow: inset rgba(0, 0, 0, 0.1) 0px -0.15em 0px, inset rgba(255, 255, 255, 0.2) 0px 0.15em 0px, rgba(0, 0, 0, 0.3) 0px 0.1em 0.3em;
  text-align: center;
  cursor: pointer;
  overflow: hidden; 
  
  color: #222;
  text-shadow: rgba(127, 127, 127, 0.4) 0 1px 0;
  background-color: #ebebeb;
  background-image: linear-gradient(to bottom, white, #ebebeb);   
  
  width: 100px;
  height: 40px;
  line-height: 40px;
  margin: 7px;
  outline:none;  /* no focus outline */
  font-size:110%;
}

.sc-btn:hover {
  color: #222;
  background-color: #d2d2d2;
  background-image: linear-gradient(to bottom, white, #d2d2d2);
  background-color: #fdfdfd;   
}

.sc-btn:active {
    box-shadow: rgba(255, 255, 255, 0.2) 0 0.1em 0, inset rgba(0, 0, 0, 0.3) 0px 0.25em 1em; 
    color: #fff;
    background-color: #dfdfdf;
    background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
}
.sc-btn:checked  {

  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
}
.sc-btn:disabled {
   color: #ddd;
}

.sc-btn[disabled="true"] {
    box-shadow: initial;
}
.sc-btn[disabled="true"] > .sc-span {
    opacity: 0.3; // for buttons with image
}

input[type="range"]:disabled {
    opacity: 0.4;
}


input:disabled + .sc-btn,
input:disabled + .sc-btn:hover,
input:disabled + .sc-btn:active, 
.sc-btn[disabled="true"] {
  color:#ddd;
  background-image: linear-gradient(to bottom, white, #ebebeb);
  box-shadow: initial;
}
.sc-btn:disabled + span {
  opacity:0.6
}


#addingCube {
  background-image: linear-gradient(to bottom, white, #DADAFD);
}
#addingCube:active, #addingCubeCheck:checked + #addingCube{
    color: #fff;
    background-image: linear-gradient(to bottom, #61adf4, #1067c1); 
}
#removingCube {
  background-image: linear-gradient(to bottom, white, #FDDADA);
}
#removingCube {
    left: 115px;
}
#removingCube:active, #removingCubeCheck:checked + #removingCube{
    color: #fff;
    background-image: linear-gradient(to bottom, #f57979, #e32323); 
}

#aboutBtn {
   right: 8px;
   width: 40px;
   bottom: 8px;
}

#urlBtn {
   right: 8px;
   width: 40px;
   bottom: 55px;
   height: 30px;
   background: url(url-icon_s3.png) #ebebeb center no-repeat;
}


.popupBack {
    display: none;
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(20,20,20, 0.82);
    top: 0;
    left: 0;
}
.popupWin {
    position: absolute;
    width: 600px;
    height: 460px;
    top: 25%;
    left: 0;
    right: 0;
    margin-left: auto;
    margin-right: auto;
    background: #FFF;
    border-radius: 15px;
    padding: 20px;
}

h1, h2, h3 {
    margin: 0;
    font-family: Tahoma;
}
h3 {
    font-size: 12px;
    font-family: monospace;
    margin: 30px 0 0 0;
}
h2 {
    font-size: 20px;
}
h1 {
    font-size: 30px;
    margin: 0 0 0 30px;
}
#urlPopup {
    position: absolute;
    bottom: 100px;
    right: 16px;
    width: 300px;
    height: 36px;
    background: #ededed;
    border-radius: 6px;
    border: 1px outset #A9A7A7;
    visibility: hidden;
}
#urlEdit {
    height: 20px;
    margin: 5px;
    width: 286px;
    
}

#addFamBtn{
    width: 34px;
    height: 34px;
    margin: 0 7px 7px 7px;
}
.addCubeBtn {
    width: 34px;
    height: 25px;
    left: 150px;
    margin: 0;
}
.addCubeBtnIn {
    background: url(plus.png) center no-repeat; 
    display: inline-block;
    width: 34px;
    height: 24px;
    vertical-align: top;
}
.linklike {
    cursor: pointer;
    color: blue;
    text-decoration: underline;
}
#picEditWin {
    height: 550px;
}


#editDoneBtn {
   right: 8px;
   width: 60px;
   bottom: 8px;
}

.color {
   padding: .5em;
   margin-right: .4em;
   border: 1px solid #aaa;
   border-radius: 3px;
   width: 140px;
   font-family: monospace;
   font-size: 110%;
}

#editUploadBtn {
   width: 40px;
   margin: 0 0 0 10px;
}
#editUploadBtnIn {
   background: url(upload.png) center no-repeat; 
   display: inline-block; 
   width: 40px; 
   height: 36px;

}
#editActionPieces {
    top: 20px;
    right: 40px
}


input:checked + .sc-btn
{
  background-color: #dfdfdf;
  background-image: linear-gradient(to bottom, #479ceb, #1067c1); 
  color: #fff;
}

#editActionMove {
    top: 70px;
    right: 40px
}

#editRotL {
    top: 120px;
    right: 45px;
    width: 40px;
}
#editRotR {
    top: 120px;
    right: 95px;
    width: 40px;
}
#editRotLIn {
    background: url(rot_left.png) center no-repeat;
    display: inline-block;
    width: 40px;
    height: 38px;
}
#editRotRIn {
    background: url(rot_right.png) center no-repeat;
    display: inline-block;
    width: 40px;
    height: 38px;    
}


#editBackColor {
    position: absolute;
    width: 60px;
    right: 65px;
    top: 240px;
}
#editFrontColor {
    position: absolute;
    width: 60px;
    right: 65px;
    top: 285px;
}
#editBlackSel {
    position: absolute;
    width:90px;
    right: 57px;
    top: 330px;
    height: 26px;
    border-radius: 4px;
}

#editZoomSlider {
    position: absolute;
    height: 200px;
    width: 40px;
    right: 8px;
    top: 30px;
    -webkit-appearance: slider-vertical;
    writing-mode: bt-lr
}
#editZoomText {
    position: absolute;
    top: 240px;
    width: 40px;
    right: 8px;
    text-align: center;
    height: 20px;
}

.editFillRadio, .editFillLabel {
    font-family: "Helvetica Neue", "Helvetica", sans-serif;
    font-size:110%;
    margin: 6px;
}
#editFillColor {

}
#editFillTexture {

}
.fillRadio {
    height: 40px;
    width: 150px;
    position: static;
    margin: 1px;
    text-align: left;
    text-indent: 10px;
}


#editFileButton {
    position: static;
    height: 40px;
    margin: 1px 1px 1px 10px;
    width: 70px;
}

.editText:disabled {
    color: #b0b0b0;
    background-color: #ececec;
    border: #b0b0b0 solid 1px;
}
.editText {
    border: #7c7c7c solid 1px;
    border-radius: 4px;
}

#editFileName {
    height: 24px;
    margin: 7px 1px 7px 10px;
    width: 250px;
    text-indent: 5px;
    vertical-align: top; 
}

#editUploadProgress {
    position: absolute;
    top: 470px;
    left: 185px;
    width: 338px;
    height: 25px;
    visibility: hidden;
}
#editErrMsg {
position: absolute;
    top: 460px;
    left: 280px;
    color: red;
    font-family: tahoma;
    font-weight: bold;
}

</style>
</head>
<body onload="start()" onresize="doResize()" >
    <div id="side_ctrl">
    <input id="addingCubeCheck" class="hidden" onclick="triggerAdd()" type="checkbox">
    <label id="addingCube" class="sc-btn" for="addingCubeCheck" >Add</label>
    <input id="removingCubeCheck" class="hidden" onclick="triggerRemove()" type="checkbox"/>
    <label id="removingCube" class="sc-btn" for="removingCubeCheck"/>Remove</label>
    <label id="aboutBtn" class="sc-btn" onclick="triggerAbout(true)"/>?</label>
    <label id="urlBtn" class="sc-btn" onclick="triggerUrl(true)"/></label>
    <div id="side_rel" class="in_rel">
      <div id="fams_cont"></div>
      <label id="addFamBtn" class="sc-btn" onclick="triggerAddFam()"/>
      <span style="background: url(plus.png) center no-repeat; display: inline-block; width: 34px; height: 33px;"></span></label>
    </div>
    <div id="editBack" class="popupBack"><div id="picEditWin" class="popupWin">
        <canvas id="editCanvas" width="590", height="450"></canvas>
        <label id="editDoneBtn" class="sc-btn" onclick="triggerEditDone()"/>Done</label>
        <input id="editBackColor" class="color" />
        <input id="editFrontColor" class="color" />
        <select id="editBlackSel" oninput="triggerBlackSel()">
            <option value="auto">Auto Lines</option>
            <option value="normal">Normal Lines</option>
            <option value="white">White Lines</option>
        </select>
        
        <input id="editActionPiecesCheck" class="hidden" onclick="triggerAction(1)" type="checkbox">
        <label id="editActionPieces" class="sc-btn" for="editActionPiecesCheck"/>Edit Pieces</label>
        <input id="editActionMoveCheck" class="hidden" onclick="triggerAction(2)" type="checkbox">
        <label id="editActionMove" class="sc-btn" for="editActionMoveCheck"/>Move Image</label>
        <input id="editZoomSlider" type="range" orient="vertical" min="20" max="200" step="1" oninput="changeImgZoom(1,editZoomSlider.value)"/>
        <input id="editZoomText" type="text" class="editText" oninput="changeImgZoom(2,parseFloat(editZoomText.value))"/>
        <label id="editRotL" class="sc-btn" onclick="triggerRotate(-1)">
            <span id="editRotLIn" class="sc-span"></span></label>
        <label id="editRotR" class="sc-btn" onclick="triggerRotate(1)">
            <span id="editRotRIn" class="sc-span"></span></label>
        
        <br>
        <input id="editFillColorRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(0)">
        <label id="editFillColor" class ="sc-btn fillRadio" for="editFillColorRadio">Uniform Color</label><br>
        <input id="editFillTextureRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(0x14)">
        <label id="editFillTexture" class ="sc-btn fillRadio" for="editFillTextureRadio">From Image</label>
          <input id="editFileInput" type="file" class="hidden" onchange="return triggerFileChanged()">
          <label id="editFileButton" class="sc-btn" for="editFileInput">File...</label>
          <input id="editFileName" class="editText" type="text" value="" oninput="triggerEditChanged()">
          <label id="editUploadBtn" class="sc-btn" onclick="triggerEditUpload()"/>
            <span id="editUploadBtnIn" title="Upload Now" class="sc-span"></span></label>
          <br>
          <progress id="editUploadProgress" max="100" value="0"></progress>
          <span id="editErrMsg"></span>
        <input id="editFillMarbleRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(4)">
        <label id="editFillMarble" class ="sc-btn fillRadio" for="editFillMarbleRadio">Marble Mix</label><br>
        <input id="editFillMixRadio" class="hidden" type="radio" name="fill" onclick="changeFillSelect(2)">
        <label id="editFillMix" class ="sc-btn fillRadio" for="editFillMixRadio">Color Mix</label><br>
        

        <img id="edit_marble" src="bw_marble3_sm.jpg" style="display:none;"/>
        <img id="edit_profi" src="bw_profi2_sm.jpg" style="display:none;"/>

        <canvas id="canvas_scratch" style="display:none;"></canvas>

    </div></div></div>
    </div>
    <div id="urlPopup"><input id="urlEdit" type="text" onchange="urlEditChanged()"/></div>
    
    <canvas id="mycanvas" width="800" height="700"></canvas>
    
    <div id="aboutBack" onclick="triggerAbout(false)" class="popupBack"><div id="aboutWin" class="popupWin">
    <h1>Happy Cube Solver</h1><br>
    <h2>Designed and implemented by Shy Shalom (1995 - 2016)<br>
    <a href="mailto:shooshx@gmail.com" target="_blank">shooshx@gmail.com</a><br></h2>
    <h3>Using this program automatically implies that you respect the copyrights on the Happy Cube&copy;&reg; Puzzles.<br>
This program is indented to support you while playing live with the Happy Cube&copy;&reg; Puzzles. These puzzles are worldwide manufacturered by HAPPY bvba, Belgium, on licensed and thus restricted base (<a href="http://www.happy.be" target="_blank" id="linka">www.happy.be</a>). The Happy Cube puzzles are the result of a real invention in 1986 by Dirk Laureyssens. This means that using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law, since the Happy Cube Puzzles are worldwide protected by many US copyrights since 1987.<br>
Please note that using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law, since the Happy Cube&copy;&reg; Puzzles are worldwide protected by US copyrights since 1987.<br>
Puzzles copyright (C) Dirk Laureyssens 1986-2016. All rights reserved. The Happy Cube puzzles are protected with several US copyrights since 1987 (TXU 271722, TX2332525, TX2359816 and many others). They are exclusively manufactured by Happy bvba, B-2980 Zoersel, Belgium, and distributed worldwide by partners. Using the puzzle snits as well as puzzle piece shapes to create or manufacture your own puzzles is illegal and against law. 
Happy Cube, Little Genius, Profi Cube and Marble Cube are registered trademarks of Happy bvba, Zoersel, Belgium. 
If you have any questions concerning the usage of HAPPY materials, please send your detailed request in writing to <a href="mailto:info@happy.be" target="_blank">info@happy.be</a>. See <a href="http://www.happy.be" target="_blank">http://www.happy.be</a> for more information</h3>
    </div></div>
    
    <img id="noisetex" src='cubeTex.png' style="display:none;"/>
    <img src="arrow_up.png" style="display:none;"/>
    <img src="arrow_down.png" style="display:none;"/>
    <img id="newgenious" src="../new_genious128.png" style="display:none;"/>
    <img id="genious" src="../littlegenious128_2.png" style="display:none;"/>
    <img id="dummy_check1" src="check_int.png" style="display:none;"/> <!-- avoid flicker -->
    <img id="blank_tex" src="blank_tex.png" style="display:none;"/>
    <div id="stat"></div>
</body>
</html>
